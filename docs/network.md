# 05. 네트워크 (Computer Networks)

---

## 1. 네트워크 기본 개념

### 네트워크란? ◑

컴퓨터 네트워크는 두 대 이상의 컴퓨터가 데이터를 주고받을 수 있도록 연결된 시스템이다. 네트워크를 통해 자원을 공유하고, 원격으로 통신할 수 있다.

```
┌─────────────┐                           ┌─────────────┐
│   Client    │◀───── Network Link ─────▶│   Server    │
│  (요청자)    │                           │  (제공자)    │
└─────────────┘                           └─────────────┘
```

네트워크의 규모에 따른 분류:

| 분류 | 범위 | 예시 |
|------|------|------|
| **PAN** | 개인 영역 (~10m) | Bluetooth 연결 |
| **LAN** | 건물/캠퍼스 | 사무실 네트워크 |
| **MAN** | 도시 규모 | 도시 광역 네트워크 |
| **WAN** | 국가/대륙 | 인터넷 |

### 주요 용어

| 용어 | 설명 |
|------|------|
| **Socket** | 네트워크 통신의 끝점, IP + Port 조합 |
| **Proxy** | 클라이언트와 서버 사이의 중계 서버 |
| **PDU** | Protocol Data Unit, 각 계층의 데이터 단위 |
| **ISP** | Internet Service Provider, 인터넷 서비스 제공자 |
| **Bandwidth** | 단위 시간당 전송 가능한 데이터량 (bps) |
| **Latency** | 데이터가 출발지에서 목적지까지 걸리는 시간 |
| **Throughput** | 실제로 전송된 데이터량 (Bandwidth ≥ Throughput) |

### ⭕ Circuit Switching vs Packet Switching를 비교하라 ◑

네트워크에서 데이터를 전송하는 두 가지 기본 방식이다.

**Circuit Switching (회선 교환)**

전통적인 전화망 방식이다. 통신 시작 전에 발신자와 수신자 사이에 **전용 경로(회선)**를 설정하고, 통신이 끝날 때까지 그 경로를 독점한다.

```
통화 중에는 A-B 경로가 다른 통신에 사용될 수 없음

   [A] ════════════════════════════════ [B]
        │                          │
        └──────── 전용 경로 ────────┘
```

- **장점**: 일정한 대역폭과 지연 시간 보장 (QoS)
- **단점**: 회선 미사용 시에도 자원 점유, 비효율적

**Packet Switching (패킷 교환)**

인터넷에서 사용하는 방식이다. 데이터를 작은 **패킷** 단위로 분할하여 전송하며, 각 패킷은 독립적으로 최적 경로를 찾아간다.

```
데이터가 패킷으로 분할되어 각각 다른 경로로 전송

[원본 데이터]  →  [P1][P2][P3][P4]

   P1 ───────┬─────────────────▶
   P2 ───────┴─────┬───────────▶   목적지에서
   P3 ─────────────┴───────────▶   재조립
   P4 ─────────────────────────▶
```

- **장점**: 자원 효율적 사용, 다중 통신 가능
- **단점**: 패킷 순서 보장 안 됨, 지연 변동 발생 가능

| 구분 | Circuit Switching | Packet Switching |
|------|-------------------|------------------|
| 연결 | 전용 경로 설정 | 경로 공유 |
| 자원 | 통화 중 독점 | 필요할 때만 사용 |
| 예시 | 전통적 전화망 | 인터넷 |
| 효율성 | 낮음 | 높음 |
| 지연 | 일정 | 변동 가능 |

### Packet 손실 원인 ◑

패킷이 목적지에 도달하지 못하는 경우가 발생할 수 있다.

1. **라우터 버퍼 오버플로우**: 라우터가 처리할 수 있는 것보다 더 많은 패킷이 도착하면 큐가 가득 차서 패킷을 버림
2. **네트워크 혼잡**: 과도한 트래픽으로 인한 패킷 드롭
3. **전송 오류**: 물리적 매체의 노이즈나 간섭으로 인한 비트 오류
4. **TTL 만료**: Time To Live 값이 0이 되면 패킷 폐기 (라우팅 루프 방지)

```
TTL (Time To Live) 동작 원리:

   패킷 생성 (TTL=64)
        │
        ▼
   라우터 1 통과 (TTL=63)
        │
        ▼
   라우터 2 통과 (TTL=62)
        │
       ...
        │
        ▼
   TTL=0 → 패킷 폐기 + ICMP "Time Exceeded" 전송
```

TTL은 패킷이 네트워크에서 무한히 순환하는 것을 방지한다. 각 라우터를 지날 때마다 TTL이 1씩 감소한다.

---

## 2. OSI 7계층

### ⭕ OSI 7계층과 TCP/IP 4계층을 비교하라

OSI(Open Systems Interconnection) 모델은 ISO에서 만든 네트워크 통신의 표준 참조 모델이다. 7개의 계층으로 나누어 각 계층이 독립적인 역할을 수행한다. 실제로는 TCP/IP 4계층 모델이 더 많이 사용된다.

```
OSI 7계층                    TCP/IP 4계층
┌─────────────────┐         ┌─────────────────┐
│  7. 응용 계층    │         │                 │
├─────────────────┤         │  응용 계층       │
│  6. 표현 계층    │         │  (Application)  │
├─────────────────┤         │                 │
│  5. 세션 계층    │         │                 │
├─────────────────┤         ├─────────────────┤
│  4. 전송 계층    │         │  전송 계층       │
│                 │         │  (Transport)    │
├─────────────────┤         ├─────────────────┤
│  3. 네트워크 계층 │         │  인터넷 계층     │
│                 │         │  (Internet)     │
├─────────────────┤         ├─────────────────┤
│  2. 데이터링크   │         │  네트워크 접근   │
├─────────────────┤         │  (Network       │
│  1. 물리 계층    │         │   Access)       │
└─────────────────┘         └─────────────────┘
```

### 각 계층별 역할과 PDU

| 계층 | 역할 | PDU | 프로토콜/장비 |
|------|------|-----|--------------|
| 7. 응용 | 사용자 인터페이스 | 데이터 | HTTP, FTP, SMTP, DNS |
| 6. 표현 | 데이터 변환, 암호화 | 데이터 | SSL/TLS, JPEG |
| 5. 세션 | 연결 관리 | 데이터 | NetBIOS |
| 4. 전송 | 종단간 통신 | 세그먼트 | TCP, UDP |
| 3. 네트워크 | 라우팅, 주소 지정 | 패킷 | IP, ICMP, 라우터 |
| 2. 데이터링크 | 프레임 전송, MAC 주소 | 프레임 | Ethernet, 스위치 |
| 1. 물리 | 비트 전송 | 비트 | 케이블, 허브 |

### 계층별 상세 설명 ◑

**물리 계층 (Physical Layer)**

전기 신호, 광 신호 등의 물리적 매체를 통해 **비트 스트림**을 전송한다. 케이블 규격, 전압 레벨, 핀 배열 등을 정의한다.

- 장비: 허브, 리피터, 케이블
- 전송 매체: 동축 케이블, 광섬유, 무선

**데이터 링크 계층 (Data Link Layer)**

물리 계층의 비트 스트림을 **프레임** 단위로 구성하고, 같은 네트워크 내의 장치 간 통신을 담당한다. **MAC 주소**를 사용하여 장치를 식별한다.

```
Ethernet 프레임 구조:

┌────────────┬────────────┬──────┬─────────────┬─────┐
│  Preamble  │ MAC Header │ Type │   Payload   │ FCS │
│   (8B)     │   (12B)    │ (2B) │ (46-1500B)  │(4B) │
└────────────┴────────────┴──────┴─────────────┴─────┘
                    │
                    ▼
           ┌──────────────────────────┐
           │ 목적지 MAC │ 출발지 MAC  │
           │   (6B)    │    (6B)     │
           └──────────────────────────┘
```

- 기능: 프레이밍, 오류 검출(CRC), 흐름 제어
- 장비: 스위치, 브릿지
- 프로토콜: Ethernet, Wi-Fi (802.11)

**네트워크 계층 (Network Layer)**

서로 다른 네트워크 간의 통신을 담당한다. **IP 주소**를 기반으로 **라우팅**을 수행하여 패킷을 목적지까지 전달한다.

```
IP 패킷 구조 (IPv4):

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│Version│  IHL  │    DSCP   │ECN│         Total Length          │
├─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤
│        Identification         │Flags│    Fragment Offset      │
├─┬─┬─┬─┬─┬─┬─┬─┼─┬─┬─┬─┬─┬─┬─┬─┼─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤
│      TTL      │   Protocol    │       Header Checksum         │
├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤
│                      Source IP Address                        │
├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤
│                    Destination IP Address                     │
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
```

- 장비: 라우터
- 프로토콜: IP, ICMP, IGMP, ARP

**전송 계층 (Transport Layer)**

**종단 간(End-to-End)** 통신을 담당한다. 포트 번호를 사용하여 프로세스를 식별하고, 데이터의 신뢰성 있는 전송(TCP) 또는 빠른 전송(UDP)을 제공한다.

```
포트 번호의 역할:

   ┌────────────────────────────────────────┐
   │              호스트 (IP: 1.2.3.4)       │
   │  ┌─────────┐ ┌─────────┐ ┌─────────┐   │
   │  │ 웹 서버  │ │ 메일 서버│ │ SSH 서버 │  │
   │  │ :80     │ │ :25     │ │ :22     │  │
   │  └─────────┘ └─────────┘ └─────────┘   │
   └────────────────────────────────────────┘
        ▲            ▲            ▲
        │            │            │
   1.2.3.4:80   1.2.3.4:25   1.2.3.4:22
```

- Well-known Ports: 0-1023 (HTTP: 80, HTTPS: 443, SSH: 22)
- Registered Ports: 1024-49151
- Dynamic/Private Ports: 49152-65535

**세션, 표현, 응용 계층**

OSI 모델의 5, 6, 7계층은 TCP/IP 모델에서는 응용 계층으로 통합된다.

| 계층 | 역할 | 예시 |
|------|------|------|
| 세션 | 연결 설정, 유지, 종료 관리 | RPC, NetBIOS |
| 표현 | 데이터 형식 변환, 암호화, 압축 | SSL/TLS, JPEG, MPEG |
| 응용 | 사용자 서비스 제공 | HTTP, FTP, SMTP, DNS |

### ⭕ 캡슐화(Encapsulation)와 역캡슐화 ◑

데이터가 각 계층을 지나면서 헤더가 추가(캡슐화)되거나 제거(역캡슐화)된다.

```
송신 측 (캡슐화)                          수신 측 (역캡슐화)

┌─────────────────────────┐              ┌─────────────────────────┐
│         Data            │  응용        │         Data            │
├─────────────────────────┤              ├─────────────────────────┤
│    │        Data        │  전송        │    │        Data        │
│ TCP│                    │              │ TCP│                    │
├────┼────────────────────┤              ├────┼────────────────────┤
│ IP │ TCP │    Data      │  네트워크    │ IP │ TCP │    Data      │
├────┼─────┼──────────────┤              ├────┼─────┼──────────────┤
│Eth │ IP  │ TCP │  Data  │  데이터링크  │Eth │ IP  │ TCP │  Data  │
└────┴─────┴─────┴────────┘              └────┴─────┴─────┴────────┘
         │                                         ▲
         └────────── 네트워크 전송 ──────────────────┘
```

---

## 3. TCP/IP

### ⭕ TCP와 UDP의 차이는?

TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)는 전송 계층의 대표적인 프로토콜이다.

| 구분 | TCP | UDP |
|------|-----|-----|
| 연결 | 연결 지향 (3-way handshake) | 비연결 |
| 신뢰성 | 보장 (재전송, 순서 보장) | 보장 안 함 |
| 속도 | 상대적으로 느림 | 빠름 |
| 헤더 크기 | 20-60 bytes | 8 bytes |
| 흐름/혼잡 제어 | 있음 | 없음 |
| 용도 | 웹, 이메일, 파일 전송 | 스트리밍, DNS, 게임 |

### TCP 헤더 구조 ◑

TCP 헤더는 최소 20바이트로 구성되며, 신뢰성 있는 전송을 위한 다양한 필드를 포함한다.

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│          Source Port          │       Destination Port        │
├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤
│                       Sequence Number                         │
├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤
│                    Acknowledgment Number                      │
├─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┤
│Offset │ Rsv │U│A│P│R│S│F│           Window Size               │
├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤
│           Checksum            │       Urgent Pointer          │
├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤
│                    Options (if any)                           │
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
```

**주요 플래그:**
- **SYN**: 연결 요청
- **ACK**: 확인 응답
- **FIN**: 연결 종료 요청
- **RST**: 연결 강제 종료
- **PSH**: 버퍼링 없이 즉시 전달
- **URG**: 긴급 데이터 존재

### ⭕ TCP 3-way Handshake를 설명하라

TCP 연결 수립 과정으로, 클라이언트와 서버가 서로의 시퀀스 번호를 교환하고 연결 준비가 되었음을 확인한다.

```
Client                                        Server
   │                                             │
   │ ─────────── SYN (seq=x) ─────────────────▶ │
   │  "연결하고 싶어. 내 시퀀스 번호는 x야"         │
   │                                             │
   │ ◀───────── SYN-ACK (seq=y, ack=x+1) ────── │
   │  "알겠어. 네 번호 확인했어.                   │
   │   내 시퀀스 번호는 y야"                      │
   │                                             │
   │ ─────────── ACK (ack=y+1) ────────────────▶│
   │  "네 번호도 확인했어"                         │
   │                                             │
   │           ═══ 연결 수립 완료 ═══              │
```

**왜 3-way인가?**

양방향 통신을 위해 클라이언트와 서버 모두 상대방의 시퀀스 번호를 알아야 한다. 2-way로는 서버가 클라이언트의 수신 능력을 확인할 수 없다.

**시퀀스 번호가 랜덤인 이유:**
1. **보안**: 예측 가능한 번호는 TCP 세션 하이재킹에 취약
2. **이전 연결 구분**: 이전 연결의 패킷과 새 연결의 패킷을 구분

### TCP 4-way Handshake (연결 종료) ◑

TCP 연결 종료는 4단계로 이루어진다. **Half-Close** 상태가 존재하여 한쪽이 FIN을 보내도 다른 쪽은 계속 데이터를 보낼 수 있다.

```
Client                                        Server
   │                                             │
   │ ─────────── FIN ─────────────────────────▶ │
   │  "더 이상 보낼 데이터 없어"                    │
   │                                             │
   │ ◀───────── ACK ─────────────────────────── │
   │  "알겠어"                                    │
   │                                             │
   │      (서버가 남은 데이터 전송 가능)            │
   │                                             │
   │ ◀───────── FIN ─────────────────────────── │
   │  "나도 끝났어"                               │
   │                                             │
   │ ─────────── ACK ─────────────────────────▶ │
   │  "알겠어"                                    │
   │                                             │
   │        ═══ 연결 종료 완료 ═══                 │
```

**TIME_WAIT 상태:**

마지막 ACK를 보낸 후 클라이언트는 바로 연결을 닫지 않고 일정 시간(보통 2MSL, Maximum Segment Lifetime) 동안 대기한다.

```
Client 상태 전이:

ESTABLISHED ──FIN전송──▶ FIN_WAIT_1 ──ACK수신──▶ FIN_WAIT_2
                                                      │
                                                   FIN수신
                                                      │
                                                      ▼
CLOSED ◀────2MSL경과──── TIME_WAIT ◀───ACK전송───────┘
```

**TIME_WAIT의 목적:**
1. 마지막 ACK가 손실될 경우 재전송을 처리
2. 이전 연결의 지연 패킷이 새 연결에 영향을 주는 것 방지

### ⭕ TCP 흐름 제어와 혼잡 제어를 설명하라 ◑

**흐름 제어 (Flow Control)**

**목적**: 수신자의 버퍼 오버플로우 방지

수신자가 처리할 수 있는 속도보다 빠르게 데이터가 도착하면 버퍼가 넘칠 수 있다. 흐름 제어는 **슬라이딩 윈도우** 방식으로 수신자의 처리 능력에 맞춰 송신 속도를 조절한다.

```
슬라이딩 윈도우 동작:

수신자: "내 버퍼에 여유가 1000바이트 있어" (Window Size = 1000)

송신자:
┌────┬────┬────┬────┬────┬────┬────┬────┬────┐
│ACK │ACK │전송 │전송 │전송 │대기 │대기 │대기 │    │
│완료 │완료 │ 중  │ 중  │ 중  │    │    │    │    │
└────┴────┴────┴────┴────┴────┴────┴────┴────┘
           │◀──── 윈도우 ────▶│

ACK 수신 시 윈도우가 오른쪽으로 슬라이드:

┌────┬────┬────┬────┬────┬────┬────┬────┬────┐
│    │ACK │ACK │전송 │전송 │전송 │대기 │대기 │    │
│    │완료 │완료 │ 중  │ 중  │ 중  │    │    │    │
└────┴────┴────┴────┴────┴────┴────┴────┴────┘
                │◀──── 윈도우 ────▶│
```

**혼잡 제어 (Congestion Control)**

**목적**: 네트워크 혼잡 방지

네트워크에 과도한 트래픽이 발생하면 패킷 손실이 증가한다. 혼잡 제어는 네트워크 상태를 파악하여 전송량을 조절한다.

| 구분 | 흐름 제어 | 혼잡 제어 |
|------|----------|----------|
| 목적 | 수신자 버퍼 오버플로우 방지 | 네트워크 혼잡 방지 |
| 방법 | 슬라이딩 윈도우 | AIMD, Slow Start |
| 관점 | 송신자-수신자 간 | 네트워크 전체 |

### TCP 혼잡 제어 알고리즘 ◑

**1. Slow Start (느린 시작)**

연결 초기에 전송량을 지수적으로 증가시킨다. cwnd(Congestion Window)를 1 MSS(Maximum Segment Size)에서 시작하여 ACK를 받을 때마다 2배로 증가시킨다.

```
cwnd 변화 (Slow Start):

cwnd
  │                              ┌──── Threshold 도달
  │                              ▼
16├────────────────────────────●─────
  │                          ╱
 8├────────────────────────●
  │                      ╱
 4├────────────────────●
  │                  ╱
 2├────────────────●
  │              ╱
 1├────────────●
  │
  └────────────┬─────┬─────┬─────┬───▶ RTT
               1     2     3     4
```

**2. Congestion Avoidance (혼잡 회피)**

Slow Start Threshold(ssthresh)에 도달하면 선형적으로 증가한다. RTT마다 cwnd를 1씩 증가시킨다 (AIMD - Additive Increase Multiplicative Decrease).

```
혼잡 감지 시:

손실 발생!
    │
    ▼
┌─────────────────────────────────┐
│  ssthresh = cwnd / 2            │
│  cwnd = 1 (Slow Start 재시작)   │  ← Timeout 발생 시
│  또는                           │
│  cwnd = ssthresh (Fast Recovery)│  ← 3 Duplicate ACK 시
└─────────────────────────────────┘
```

**3. Fast Retransmit & Fast Recovery**

3개의 중복 ACK를 받으면 타임아웃을 기다리지 않고 즉시 재전송한다.

```
                    cwnd
                     │
Slow Start          │      ╱\
                    │    ╱   \    Congestion
        ●────────●─│──●      \    Avoidance
      ╱            │         ╲●─────────
    ╱              │          │ 3 Dup ACK
  ●                │          │ (Fast Recovery)
                   │          ▼
                   │    ssthresh = cwnd/2
───────────────────┴──────────────────────▶ 시간
```

**TCP Reno vs TCP Cubic:**

| 알고리즘 | 특징 |
|----------|------|
| **Reno** | 전통적인 AIMD, 3 Dup ACK 시 Fast Recovery |
| **Cubic** | 현대 Linux 기본, 손실 후 빠른 회복을 위해 3차 함수 사용 |
| **BBR** | Google 개발, 대역폭과 RTT를 측정하여 최적 전송률 계산 |

### UDP 헤더 구조 ◑

UDP 헤더는 단 8바이트로, TCP에 비해 매우 간단하다.

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│          Source Port          │       Destination Port        │
├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤
│            Length             │           Checksum            │
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
```

**UDP의 용도:**
- DNS 쿼리 (작은 데이터, 빠른 응답)
- 실시간 스트리밍 (손실보다 지연이 더 치명적)
- 온라인 게임 (빠른 반응 필요)
- VoIP (실시간 음성 통화)

---

## 4. HTTP/HTTPS

### HTTP 메서드

| 메서드 | 설명 | 멱등성 | 안전성 |
|--------|------|--------|--------|
| GET | 리소스 조회 | O | O |
| POST | 리소스 생성 | X | X |
| PUT | 리소스 전체 수정 | O | X |
| PATCH | 리소스 일부 수정 | X | X |
| DELETE | 리소스 삭제 | O | X |

**멱등성(Idempotency)**: 같은 요청을 여러 번 해도 결과가 같다
**안전성(Safety)**: 서버 상태를 변경하지 않는다

### HTTP 상태 코드

| 범위 | 의미 | 예시 |
|------|------|------|
| 1xx | 정보 | 100 Continue |
| 2xx | 성공 | 200 OK, 201 Created |
| 3xx | 리다이렉션 | 301 Moved, 304 Not Modified |
| 4xx | 클라이언트 오류 | 400 Bad Request, 404 Not Found |
| 5xx | 서버 오류 | 500 Internal Error, 503 Unavailable |

### ⭕ HTTP와 HTTPS의 차이는?

| 구분 | HTTP | HTTPS |
|------|------|-------|
| 포트 | 80 | 443 |
| 보안 | 평문 전송 | SSL/TLS 암호화 |
| 인증서 | 불필요 | 필요 |
| 속도 | 빠름 | 약간 느림 (암호화 오버헤드) |

HTTPS는 HTTP에 SSL/TLS 암호화가 추가된 것으로, 인증서를 통해 서버를 검증하며 데이터를 암호화하여 전송한다.

### TLS 핸드셰이크 ◑

HTTPS 연결 시 TLS(Transport Layer Security) 핸드셰이크가 수행된다. TCP 연결 수립 후 암호화 통신을 위한 협상이 이루어진다.

```
TLS 1.2 핸드셰이크:

Client                                        Server
   │                                             │
   │ ──── ClientHello ─────────────────────────▶│
   │   (지원 암호화 방식, 랜덤값)                  │
   │                                             │
   │ ◀───────────────────────── ServerHello ────│
   │   (선택된 암호화 방식, 랜덤값)                │
   │                                             │
   │ ◀───────────────────────── Certificate ────│
   │   (서버 인증서)                              │
   │                                             │
   │ ◀──────────────────── ServerKeyExchange ───│
   │                                             │
   │ ◀──────────────────── ServerHelloDone ─────│
   │                                             │
   │ ──── ClientKeyExchange ───────────────────▶│
   │   (Pre-Master Secret)                       │
   │                                             │
   │ ──── ChangeCipherSpec ────────────────────▶│
   │ ──── Finished ────────────────────────────▶│
   │                                             │
   │ ◀──────────────────── ChangeCipherSpec ────│
   │ ◀──────────────────── Finished ────────────│
   │                                             │
   │        ═══ 암호화 통신 시작 ═══               │
```

**TLS 1.3의 개선점:**
- 핸드셰이크를 1-RTT로 단축 (TLS 1.2는 2-RTT)
- 0-RTT 재연결 지원
- 취약한 암호화 방식 제거 (RSA 키 교환 제거)

### HTTP 버전별 특징 ◑

| 버전 | 특징 |
|------|------|
| HTTP/1.1 | Keep-Alive, 파이프라이닝 |
| HTTP/2 | 멀티플렉싱, 헤더 압축, 서버 푸시 |
| HTTP/3 | QUIC 프로토콜 (UDP 기반), 연결 지연 감소 |

**HTTP/1.1의 한계: Head-of-Line Blocking**

HTTP/1.1에서는 하나의 연결에서 요청을 순차적으로 처리해야 한다. 앞선 요청이 지연되면 뒤의 요청도 대기해야 한다.

```
HTTP/1.1 (파이프라이닝):

요청:  ├──req1──┼──req2──┼──req3──┤
응답:  ├────────res1────────┼──res2──┼res3┤
                    │
                    └── req1 응답이 늦으면 모두 대기
```

**HTTP/2의 멀티플렉싱**

하나의 연결에서 여러 요청/응답을 **스트림**으로 분리하여 동시에 처리한다.

```
HTTP/2 멀티플렉싱:

       ┌────────────────────────────────────────────┐
       │  하나의 TCP 연결                            │
       │                                            │
       │  Stream 1: ▓▓▓▓▓░░░░▓▓▓▓▓                  │
       │  Stream 2: ░░░▓▓▓▓▓▓▓▓░░░░░                │
       │  Stream 3: ▓▓░░░░░▓▓▓▓▓▓▓▓                 │
       │                                            │
       └────────────────────────────────────────────┘

       ▓ = 데이터 전송 중, ░ = 다른 스트림 처리 중
```

**HTTP/3 (QUIC)**

TCP 대신 UDP 기반의 QUIC 프로토콜을 사용한다.

```
프로토콜 스택 비교:

HTTP/2:              HTTP/3:
┌─────────┐          ┌─────────┐
│  HTTP/2 │          │  HTTP/3 │
├─────────┤          ├─────────┤
│   TLS   │          │  QUIC   │ ← TLS 1.3 내장
├─────────┤          ├─────────┤
│   TCP   │          │   UDP   │
└─────────┘          └─────────┘
```

**QUIC의 장점:**
- 0-RTT 연결 재개 (이전에 연결했던 서버)
- 스트림별 독립적 손실 복구 (HOL Blocking 완화)
- 연결 마이그레이션 (IP 변경 시에도 연결 유지)

---

## 5. DNS ◑

### ⭕ DNS란? 동작 원리를 설명하라

DNS(Domain Name System)는 도메인 이름을 IP 주소로 변환하는 분산 데이터베이스 시스템이다. 인터넷의 "전화번호부" 역할을 한다.

**DNS 조회 과정:**

```
1. 브라우저가 "www.example.com" 접속 시도

   ┌────────────────────────────────────────────────────────────┐
   │  1. 로컬 캐시 확인 (브라우저 → OS)                           │
   │     └─ 캐시 히트 시 즉시 반환                                │
   │                                                            │
   │  2. Recursive Resolver (ISP DNS) 쿼리                      │
   │     └─ 캐시 히트 시 반환                                    │
   │                                                            │
   │  3. Root Name Server 쿼리                                   │
   │     └─ ".com TLD 서버는 a.gtld-servers.net이야"              │
   │                                                            │
   │  4. TLD Server (.com) 쿼리                                  │
   │     └─ "example.com의 NS는 ns1.example.com이야"             │
   │                                                            │
   │  5. Authoritative Name Server 쿼리                          │
   │     └─ "www.example.com의 IP는 93.184.216.34야"             │
   │                                                            │
   │  6. 결과 캐싱 (TTL 기간 동안)                                │
   └────────────────────────────────────────────────────────────┘
```

```
전체 DNS 조회 흐름:

사용자                 Recursive              Root          TLD        Authoritative
  │                    Resolver                │             │              │
  │                        │                   │             │              │
  ├──"www.example.com"───▶│                   │             │              │
  │                        ├─"com 어디?"──────▶│             │              │
  │                        │◀─"TLD 서버 주소"──┤             │              │
  │                        ├─"example.com?"────────────────▶│              │
  │                        │◀─"NS 서버 주소"───────────────┤              │
  │                        ├─"www.example.com?"─────────────────────────▶│
  │                        │◀─"93.184.216.34"──────────────────────────┤
  │◀───"93.184.216.34"────┤                   │             │              │
```

| DNS 서버 종류 | 역할 |
|--------------|------|
| Root Server | TLD 서버 위치 안내 (전 세계 13개 루트 존재) |
| TLD Server | .com, .org 등 도메인 확장자 관리 |
| Authoritative | 실제 도메인-IP 매핑 보유 |
| Recursive Resolver | 클라이언트 대신 재귀적 조회 수행 |

### DNS 레코드 타입 ◑

| 레코드 | 용도 | 예시 |
|--------|------|------|
| **A** | 도메인 → IPv4 | example.com → 93.184.216.34 |
| **AAAA** | 도메인 → IPv6 | example.com → 2606:2800:220:1::248e:c |
| **CNAME** | 도메인 → 다른 도메인 (별칭) | www.example.com → example.com |
| **MX** | 메일 서버 지정 | example.com → mail.example.com |
| **NS** | 네임서버 지정 | example.com → ns1.example.com |
| **TXT** | 텍스트 정보 | SPF, DKIM 등 |
| **SOA** | 영역 권한 시작 정보 | 마스터 서버, 갱신 간격 등 |

### DNS 보안 ◑

**DNS Spoofing/Cache Poisoning**

공격자가 DNS 응답을 위조하여 사용자를 악성 사이트로 유도한다.

```
정상적인 DNS 조회:
사용자 ──▶ DNS ──▶ "bank.com = 1.2.3.4" ──▶ 실제 은행

DNS Spoofing:
사용자 ──▶ DNS ──▶ 공격자 가로채기
                    └──▶ "bank.com = 6.6.6.6" ──▶ 가짜 사이트
```

**방어책:**
- **DNSSEC**: DNS 응답에 디지털 서명 추가
- **DNS over HTTPS (DoH)**: DNS 쿼리를 HTTPS로 암호화
- **DNS over TLS (DoT)**: DNS 쿼리를 TLS로 암호화

---

## 6. IP 주소 체계 ◑

### IPv4 vs IPv6

| 구분 | IPv4 | IPv6 |
|------|------|------|
| 주소 길이 | 32비트 | 128비트 |
| 표기 | 10진수 (192.168.1.1) | 16진수 (2001:db8::1) |
| 주소 수 | 약 43억 개 | 거의 무한 (3.4×10³⁸) |
| NAT 필요성 | 필요 | 불필요 |
| 헤더 크기 | 20-60 bytes | 40 bytes (고정) |
| 체크섬 | 있음 | 없음 (상위 계층에서 처리) |

### 서브넷과 CIDR ◑

**서브네팅**은 큰 네트워크를 작은 네트워크로 분할하는 것이다. **CIDR**(Classless Inter-Domain Routing)은 IP 주소와 서브넷 마스크를 함께 표기하는 방식이다.

**CIDR 표기법**: `192.168.1.0/24` → 앞 24비트가 네트워크, 뒤 8비트가 호스트

```
192.168.1.0/24의 의미:

IP 주소:     11000000.10101000.00000001.00000000
서브넷 마스크: 11111111.11111111.11111111.00000000
             ├────── 네트워크 ID ──────┤├호스트┤
                    (24비트)            (8비트)

사용 가능한 호스트: 2⁸ - 2 = 254개
  - 192.168.1.0: 네트워크 주소 (사용 불가)
  - 192.168.1.255: 브로드캐스트 주소 (사용 불가)
  - 192.168.1.1 ~ 192.168.1.254: 호스트 할당 가능
```

| CIDR | 서브넷 마스크 | 호스트 수 |
|------|--------------|----------|
| /24 | 255.255.255.0 | 254 |
| /16 | 255.255.0.0 | 65,534 |
| /8 | 255.0.0.0 | 16,777,214 |

### 사설 IP 대역 ◑

인터넷에서 라우팅되지 않는 내부 네트워크용 주소:

| 클래스 | 범위 | CIDR |
|--------|------|------|
| A | 10.0.0.0 ~ 10.255.255.255 | 10.0.0.0/8 |
| B | 172.16.0.0 ~ 172.31.255.255 | 172.16.0.0/12 |
| C | 192.168.0.0 ~ 192.168.255.255 | 192.168.0.0/16 |

### ⭕ ARP(Address Resolution Protocol)란? ◑

ARP는 IP 주소를 MAC 주소로 변환하는 프로토콜이다. 같은 네트워크 내에서 실제로 데이터를 전송하려면 MAC 주소가 필요하다.

**동작 과정:**

```
1. ARP Request (브로드캐스트)

호스트 A (192.168.1.10)                    호스트 B (192.168.1.20)
    │                                           │
    │  "192.168.1.20의 MAC 주소가 뭐야?"          │
    ├──────────────────────────────────────────▶│
    ├──────────────────────────────────────────▶│ 모든 호스트
    ├──────────────────────────────────────────▶│
    │                                           │
    │                                           │
2. ARP Reply (유니캐스트)                        │
    │                                           │
    │◀─ "내 MAC은 AA:BB:CC:DD:EE:FF야" ─────────┤
    │                                           │

3. ARP 캐시에 저장
   192.168.1.20 → AA:BB:CC:DD:EE:FF
```

**ARP 스푸핑 공격:**

공격자가 거짓 ARP 응답을 보내 트래픽을 가로채는 Man-in-the-Middle 공격

```
정상:
A ────────────────▶ 라우터

ARP 스푸핑:
A ────▶ 공격자 ────▶ 라우터
         │
         └── A에게 "라우터 MAC = 내 MAC"이라고 거짓 응답
```

### ⭕ NAT(Network Address Translation)란? ◑

NAT는 사설 IP를 공인 IP로 변환하여 여러 장치가 하나의 공인 IP를 공유하게 하는 기술이다. IPv4 주소 부족 문제를 해결한다.

```
NAT 동작 과정:

내부 네트워크                   NAT 라우터                    외부 서버
                                  │
[PC1] 192.168.1.10 ─┐             │
                    ├─▶ 203.0.113.5 ─────────────▶ 웹 서버
[PC2] 192.168.1.11 ─┘             │
                                  │
                      NAT 테이블:
                      ┌─────────────────────────────────────────┐
                      │ 내부 IP:Port    │ 외부 IP:Port           │
                      ├─────────────────┼────────────────────────┤
                      │ 192.168.1.10:45000 │ 203.0.113.5:10001 │
                      │ 192.168.1.11:52000 │ 203.0.113.5:10002 │
                      └─────────────────┴────────────────────────┘
```

| 유형 | 설명 |
|------|------|
| **Static NAT** | 1:1 매핑, 서버 공개용 |
| **Dynamic NAT** | 공인 IP 풀에서 동적 할당 |
| **PAT/NAPT** | 포트 번호로 구분 (가장 일반적, 공유기에서 사용) |

---

## 7. 네트워크 장비

### ⭕ Hub, Switch, Router의 차이는?

| 장비 | 계층 | 역할 | 데이터 전달 방식 |
|------|------|------|------------------|
| **Hub** | L1 (물리) | 신호 증폭 | 모든 포트로 브로드캐스트 |
| **Switch** | L2 (데이터링크) | 프레임 전달 | MAC 주소 기반, 해당 포트로만 |
| **Router** | L3 (네트워크) | 패킷 라우팅 | IP 주소 기반, 최적 경로 선택 |
| **공유기** | L3-L7 | 가정용 통합 장비 | 라우터 + NAT + DHCP + 방화벽 |

### 장비별 상세 동작 ◑

**Hub (허브)**

물리 계층에서 동작하며, 받은 신호를 모든 포트로 **브로드캐스트**한다. 충돌 도메인이 확장되어 성능이 저하된다.

```
Hub의 동작:

   PC1 ──▶ Hub ──▶ PC2 (대상)
             ├──▶ PC3 (불필요하게 수신)
             └──▶ PC4 (불필요하게 수신)
```

**Switch (스위치)**

데이터 링크 계층에서 동작하며, **MAC 주소 테이블**을 학습하여 해당 포트로만 프레임을 전달한다.

```
Switch의 MAC 주소 학습:

1. PC1이 프레임 전송
   Switch: "PC1 MAC = Port 1에 연결" (MAC 테이블에 기록)

2. PC2에 전달할 때
   Switch: MAC 테이블 조회 → Port 2로만 전송

MAC Address Table:
┌──────────────────┬────────┐
│ MAC Address      │ Port   │
├──────────────────┼────────┤
│ AA:BB:CC:DD:EE:11│ Port 1 │
│ AA:BB:CC:DD:EE:22│ Port 2 │
│ AA:BB:CC:DD:EE:33│ Port 3 │
└──────────────────┴────────┘
```

**Router (라우터)**

네트워크 계층에서 동작하며, **라우팅 테이블**을 사용하여 패킷을 목적지 네트워크로 전달한다.

```
Routing Table:
┌────────────────┬────────────┬───────────┐
│ Destination    │ Gateway    │ Interface │
├────────────────┼────────────┼───────────┤
│ 192.168.1.0/24 │ directly   │ eth0      │
│ 10.0.0.0/8     │ 192.168.1.1│ eth0      │
│ 0.0.0.0/0      │ 192.168.1.254│ eth0    │ ← Default Gateway
└────────────────┴────────────┴───────────┘
```

### L4/L7 스위치 ◑

고급 스위칭 장비로, 로드밸런싱과 고가용성을 제공한다.

| 장비 | 계층 | 기능 |
|------|------|------|
| **L4 Switch** | 전송 | IP/Port 기반 로드밸런싱 |
| **L7 Switch** | 응용 | HTTP 헤더, URL 기반 로드밸런싱 |

```
L7 스위치 예시:

요청: GET /api/users
  │
  ▼
┌─────────────────────────────────────────┐
│                L7 Switch                │
│                                         │
│  URL 패턴       → 서버 그룹              │
│  /api/*        → API 서버 풀            │
│  /static/*     → CDN                   │
│  /*            → 웹 서버 풀             │
└─────────────────────────────────────────┘
```

---

## 8. 소켓 프로그래밍 ◑

### ⭕ 소켓(Socket)이란?

소켓은 네트워크 통신의 **종단점(endpoint)**으로, IP 주소와 포트 번호의 조합이다. 운영체제가 제공하는 네트워크 통신 인터페이스이다.

```
소켓 = IP 주소 + Port 번호

예: 192.168.1.10:8080

   ┌──────────────────────────────────────┐
   │         운영체제 커널                  │
   │                                      │
   │    ┌────────────┐ ┌────────────┐    │
   │    │  Socket A  │ │  Socket B  │    │
   │    │ :8080     │ │ :3000     │    │
   │    └────────────┘ └────────────┘    │
   │          │              │            │
   │    ┌─────┴──────────────┴─────┐     │
   │    │      TCP/IP 스택          │     │
   │    └──────────────────────────┘     │
   └──────────────────────────────────────┘
```

### 소켓 통신 흐름 ◑

**TCP 서버-클라이언트:**

```
      Server                                 Client
        │                                      │
  socket()  ← 소켓 생성                         │
        │                                      │
  bind()  ← 주소 바인딩                         │
        │                                    socket()
  listen()  ← 연결 대기 상태                     │
        │                                      │
        │◀──────── connect() ─────────────────┤
        │                                      │
  accept()  ← 연결 수락                          │
        │        (새 소켓 반환)                   │
        │                                      │
        │◀──────── send() ────────────────────┤
        │                                      │
  recv()  ← 데이터 수신                          │
        │                                      │
        ├──────── send() ─────────────────────▶│
        │                                      │
        │                               recv()  ← 데이터 수신
        │                                      │
  close()  ← 연결 종료                     close()
```

**TCP 소켓 API 호출 순서:**

```
TCP 서버:
socket() → bind() → listen() → accept() → recv()/send() → close()

TCP 클라이언트:
socket() → connect() → recv()/send() → close()
```

**UDP (서버/클라이언트):**

```
UDP는 연결 수립 없이 바로 데이터 전송:

socket() → bind() → recvfrom()/sendto() → close()
```

### 소켓 API 주요 함수 ◑

| 함수 | 설명 |
|------|------|
| `socket()` | 소켓 생성 (파일 디스크립터 반환) |
| `bind()` | 소켓에 주소(IP+Port) 바인딩 |
| `listen()` | 연결 대기 상태로 전환 (백로그 큐 설정) |
| `accept()` | 연결 수락, 새 소켓 반환 |
| `connect()` | 서버에 연결 요청 |
| `send()/recv()` | 데이터 송수신 (TCP) |
| `sendto()/recvfrom()` | 데이터 송수신 (UDP) |
| `close()` | 소켓 종료 |

```c
// TCP 서버 예제 (C)
int server_fd = socket(AF_INET, SOCK_STREAM, 0);

struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_addr.s_addr = INADDR_ANY;
addr.sin_port = htons(8080);

bind(server_fd, (struct sockaddr*)&addr, sizeof(addr));
listen(server_fd, 128);  // 백로그 큐 크기

int client_fd = accept(server_fd, NULL, NULL);

char buffer[1024];
recv(client_fd, buffer, sizeof(buffer), 0);
send(client_fd, "Hello", 5, 0);

close(client_fd);
close(server_fd);
```

### ⭕ Blocking vs Non-Blocking I/O ◑

| 구분 | Blocking | Non-Blocking |
|------|----------|--------------|
| 동작 | 작업 완료까지 대기 | 즉시 반환 |
| 반환값 | 결과 또는 에러 | 결과, EAGAIN, 또는 에러 |
| 장점 | 구현 단순 | 다른 작업 가능 |
| 단점 | 스레드 차단 | 폴링 필요, 구현 복잡 |

```
Blocking I/O:

Thread ──────────────────────────────────────────▶
         │           blocked           │
         ├─────────────────────────────┤
         read()                    return
         호출                       (데이터 수신)


Non-Blocking I/O:

Thread ──────────────────────────────────────────▶
         │    │    │    │           │
         read read read read      read
         (-1) (-1) (-1) (-1)     (데이터)
        EAGAIN EAGAIN           성공
```

### ⭕ I/O 멀티플렉싱이란? ◑

하나의 스레드에서 **여러 I/O를 동시에 감시**하고 처리하는 기법이다. 연결당 스레드를 생성하는 것보다 효율적이다.

```
멀티플렉싱 개념:

          ┌───────────────────────────────┐
          │        단일 스레드             │
          │                               │
          │    select/poll/epoll          │
          │         │                     │
          │    ┌────┼────┬────┬────┐     │
          │    ▼    ▼    ▼    ▼    ▼     │
          │  sock1 sock2 sock3 sock4 sock5│
          │                               │
          │  "준비된 소켓만 처리"           │
          └───────────────────────────────┘
```

| 방식 | 특징 | 한계 |
|------|------|------|
| **select()** | POSIX 표준, 이식성 좋음 | fd 수 제한 (1024), 매번 전체 검사 O(n) |
| **poll()** | fd 수 제한 없음 | 매번 전체 검사 O(n) |
| **epoll** (Linux) | 이벤트 기반, 효율적 O(1) | Linux 전용 |
| **kqueue** (BSD) | 이벤트 기반 | BSD/macOS 전용 |
| **IOCP** (Windows) | 비동기 I/O | Windows 전용 |

### epoll 동작 방식 ◑

epoll은 Linux에서 제공하는 고성능 I/O 멀티플렉싱 메커니즘이다.

```c
// 1. epoll 인스턴스 생성
int epfd = epoll_create(1);

// 2. 관심 이벤트 등록
struct epoll_event ev;
ev.events = EPOLLIN;  // 읽기 이벤트
ev.data.fd = sockfd;
epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &ev);

// 3. 이벤트 대기 (블로킹)
struct epoll_event events[MAX_EVENTS];
int n = epoll_wait(epfd, events, MAX_EVENTS, timeout);

// 4. 발생한 이벤트만 처리 (O(준비된 fd 수))
for (int i = 0; i < n; i++) {
    int fd = events[i].data.fd;
    // events[i] 처리
}
```

**epoll 트리거 모드:**

| 모드 | 설명 | 특징 |
|------|------|------|
| **Level Triggered (LT)** | 조건 만족 시 계속 알림 | 기본 모드, 구현 쉬움 |
| **Edge Triggered (ET)** | 상태 변화 시에만 알림 | 고성능, Non-blocking 필수 |

```
Level Triggered:
데이터: ████████████████
알림:   ▲  ▲  ▲  ▲  ▲  ▲  ← 매번 알림

Edge Triggered:
데이터: ████████████████
알림:   ▲                  ← 데이터 도착 시 한 번만
```

### 동시 접속 처리 모델 ◑

| 모델 | 설명 | 장단점 |
|------|------|--------|
| **멀티 프로세스** | 연결당 fork() | 격리 좋음, 오버헤드 큼 |
| **멀티 스레드** | 연결당 스레드 | 공유 자원, 컨텍스트 스위칭 |
| **I/O 멀티플렉싱** | 단일 스레드 + select/epoll | 고성능, 복잡한 구현 |
| **비동기 I/O** | IOCP, io_uring | 최고 성능, 구현 난이도 높음 |

```
모델별 동시 접속 처리:

멀티 프로세스:          멀티 스레드:          I/O 멀티플렉싱:
┌─────────┐           ┌─────────┐          ┌─────────────────┐
│ 부모    │           │ 메인    │          │    단일 스레드   │
├─────────┤           ├─────────┤          │                 │
│ 자식1   │ conn1     │ 스레드1 │ conn1    │  epoll_wait()   │
├─────────┤           ├─────────┤          │    │            │
│ 자식2   │ conn2     │ 스레드2 │ conn2    │  conn1, conn2,  │
├─────────┤           ├─────────┤          │  conn3, conn4   │
│ 자식3   │ conn3     │ 스레드3 │ conn3    │                 │
└─────────┘           └─────────┘          └─────────────────┘
오버헤드: 높음         오버헤드: 중간        오버헤드: 낮음
```

### C10K Problem ◑

동시 10,000개 연결 처리 문제. 전통적인 스레드/프로세스 모델의 한계를 드러냈으며, 이벤트 기반 아키텍처로 해결한다.

**문제점:**
- 10,000개 스레드 생성 시 메모리 부족 (스레드당 스택 1MB = 10GB)
- 컨텍스트 스위칭 오버헤드
- 파일 디스크립터 제한

**해결 방법:**
- 이벤트 기반 아키텍처 (Node.js, Nginx)
- I/O 멀티플렉싱 (epoll, kqueue)
- 비동기 I/O (io_uring)
- 코루틴/경량 스레드 (Go goroutine)

```
C10K 이전 (프로세스/스레드 per 연결):

연결 수 ─────────────────────────────────▶
    │
CPU │     ╱╲
사용 │    ╱  ╲ (컨텍스트 스위칭 급증)
    │   ╱    ╲
    │  ╱      ╲ 성능 저하
    │ ╱
    └─────────────────────────────────▶

C10K 이후 (이벤트 기반):

연결 수 ─────────────────────────────────▶
    │
CPU │          ────────────────────
사용 │      ╱
    │    ╱  (선형에 가까운 확장)
    │  ╱
    │╱
    └─────────────────────────────────▶
```

---

## 9. 라우팅 ◑

### 라우팅이란?

패킷을 목적지까지 전달하기 위한 최적 경로를 찾는 과정이다. 라우터는 라우팅 테이블을 참조하여 패킷을 다음 홉(next hop)으로 전달한다.

```
라우팅 과정:

패킷: 목적지 = 8.8.8.8

라우터 A 라우팅 테이블:
┌──────────────┬─────────────┬──────────┐
│ Destination  │ Next Hop    │ Interface│
├──────────────┼─────────────┼──────────┤
│ 8.8.0.0/16   │ 10.0.0.2    │ eth1     │
│ 0.0.0.0/0    │ 10.0.0.1    │ eth0     │
└──────────────┴─────────────┴──────────┘

→ 8.8.8.8은 8.8.0.0/16에 매칭 → eth1로 10.0.0.2에 전달
```

### 정적 라우팅 vs 동적 라우팅 ◑

| 구분 | 정적 라우팅 | 동적 라우팅 |
|------|------------|------------|
| 설정 | 관리자가 수동 설정 | 프로토콜이 자동 학습 |
| 유연성 | 낮음 (변경 시 수동 수정) | 높음 (자동 대응) |
| 오버헤드 | 없음 | 라우팅 프로토콜 통신 |
| 용도 | 소규모 네트워크 | 대규모, 복잡한 네트워크 |

### 라우팅 프로토콜 ◑

| 프로토콜 | 분류 | 알고리즘 | 용도 |
|----------|------|----------|------|
| **RIP** | IGP | Distance Vector | 소규모 네트워크 |
| **OSPF** | IGP | Link State | 중대규모 네트워크 |
| **BGP** | EGP | Path Vector | 인터넷 AS 간 라우팅 |

**IGP (Interior Gateway Protocol)**: AS 내부 라우팅
**EGP (Exterior Gateway Protocol)**: AS 간 라우팅

```
인터넷 라우팅 구조:

┌─────────────────────────────────────────────────────────────┐
│                        인터넷                                │
│                                                             │
│   ┌─────────┐                           ┌─────────┐        │
│   │  AS 1   │◀───────── BGP ──────────▶│  AS 2   │        │
│   │(ISP A)  │                           │(ISP B)  │        │
│   │         │                           │         │        │
│   │  OSPF   │                           │  OSPF   │        │
│   │ (내부)  │                           │ (내부)  │        │
│   └─────────┘                           └─────────┘        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 10. ICMP와 네트워크 진단 ◑

### ICMP (Internet Control Message Protocol)

네트워크 오류 보고 및 진단에 사용되는 프로토콜이다.

| 타입 | 메시지 | 용도 |
|------|--------|------|
| 0 | Echo Reply | ping 응답 |
| 3 | Destination Unreachable | 목적지 도달 불가 |
| 8 | Echo Request | ping 요청 |
| 11 | Time Exceeded | TTL 만료 |

### ping과 traceroute ◑

**ping**: 호스트 도달 가능 여부 확인

```bash
$ ping google.com
PING google.com (142.250.190.46): 56 data bytes
64 bytes from 142.250.190.46: icmp_seq=0 ttl=116 time=8.23 ms
64 bytes from 142.250.190.46: icmp_seq=1 ttl=116 time=7.89 ms
```

**traceroute**: 경로 추적 (TTL을 1부터 증가시키며 경로 확인)

```bash
$ traceroute google.com
 1  192.168.1.1 (192.168.1.1)  1.234 ms
 2  10.0.0.1 (10.0.0.1)  5.678 ms
 3  ...
10  142.250.190.46 (142.250.190.46)  8.123 ms
```

```
traceroute 동작 원리:

TTL=1 ──▶ 라우터1 ──▶ TTL 만료 ──▶ ICMP Time Exceeded 반환
TTL=2 ──▶ 라우터1 ──▶ 라우터2 ──▶ TTL 만료 ──▶ ICMP Time Exceeded
TTL=3 ──▶ 라우터1 ──▶ 라우터2 ──▶ 라우터3 ──▶ ...
```

---

## 면접 대비 체크리스트 ◑

- [ ] OSI 7계층 vs TCP/IP 4계층
- [ ] 각 계층의 역할과 PDU
- [ ] 캡슐화와 역캡슐화
- [ ] TCP vs UDP 차이
- [ ] TCP 3-way / 4-way Handshake
- [ ] TCP 흐름 제어와 혼잡 제어
- [ ] Slow Start, Congestion Avoidance
- [ ] HTTP 메서드와 멱등성
- [ ] HTTP vs HTTPS, TLS 핸드셰이크
- [ ] HTTP/1.1, HTTP/2, HTTP/3 차이
- [ ] DNS 동작 원리와 레코드 타입
- [ ] IPv4 vs IPv6
- [ ] 서브넷과 CIDR 표기법
- [ ] ARP 프로토콜
- [ ] NAT 동작 원리와 종류
- [ ] Hub, Switch, Router 차이
- [ ] 소켓 API 함수 흐름 (TCP/UDP)
- [ ] Blocking vs Non-Blocking I/O
- [ ] I/O 멀티플렉싱 (select, poll, epoll)
- [ ] epoll의 LT/ET 모드
- [ ] C10K Problem과 해결 방법
- [ ] 정적 라우팅 vs 동적 라우팅
- [ ] ping과 traceroute 원리
