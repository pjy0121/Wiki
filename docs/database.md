# 06. 데이터베이스 (Database)

---

## 1. 데이터베이스 기본 개념

### 데이터베이스란? ◑

**데이터베이스(DB)**는 구조화된 데이터의 집합이다. 단순히 파일에 데이터를 저장하는 것과 달리, 데이터베이스는 데이터를 효율적으로 저장, 검색, 수정, 삭제할 수 있도록 설계되어 있다.

**파일 시스템 vs 데이터베이스:**

파일 시스템으로 데이터를 관리하면 여러 문제가 발생한다.

```
[파일 시스템의 문제점]

1. 데이터 중복
   - 부서A.txt: 김철수, 010-1234-5678, 개발팀
   - 부서B.txt: 김철수, 010-1234-5678, 개발팀  ← 같은 정보가 중복 저장

2. 데이터 불일치
   - 부서A.txt에서 전화번호를 수정했는데, 부서B.txt는 그대로
   - 어느 것이 맞는 정보인지 알 수 없음

3. 동시 접근 문제
   - 두 사람이 같은 파일을 동시에 수정하면?
   - 한 사람의 변경이 덮어씌워질 수 있음

4. 보안 문제
   - 파일 단위로만 접근 제어 가능
   - 특정 필드만 숨기기 어려움
```

데이터베이스는 이런 문제들을 해결하기 위해 등장했다.

### DBMS (Database Management System)

**DBMS**는 데이터베이스를 생성하고 관리하는 소프트웨어이다. 사용자와 데이터베이스 사이에서 중개자 역할을 한다.

```
┌─────────────────────────────────────────────────────────────┐
│                         사용자/애플리케이션                    │
└──────────────────────────┬──────────────────────────────────┘
                           │ SQL 쿼리
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                           DBMS                               │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────────┐   │
│  │ 쿼리처리기│ │ 트랜잭션 │ │ 동시성   │ │ 백업/복구     │   │
│  │          │ │ 관리자   │ │ 제어     │ │ 관리자       │   │
│  └──────────┘ └──────────┘ └──────────┘ └──────────────┘   │
└──────────────────────────┬──────────────────────────────────┘
                           │ 파일 I/O
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                        저장 장치 (디스크)                     │
│                     [데이터 파일들]                          │
└─────────────────────────────────────────────────────────────┘
```

**DBMS의 주요 기능:**

| 기능 | 설명 | 예시 |
|------|------|------|
| **데이터 정의 (DDL)** | 데이터 구조를 정의 | CREATE TABLE, ALTER TABLE |
| **데이터 조작 (DML)** | 데이터를 조회, 삽입, 수정, 삭제 | SELECT, INSERT, UPDATE, DELETE |
| **데이터 제어 (DCL)** | 접근 권한 관리 | GRANT, REVOKE |
| **동시성 제어** | 여러 사용자가 동시에 접근해도 데이터 일관성 유지 | 락, MVCC |
| **백업 및 복구** | 장애 발생 시 데이터 복구 | 트랜잭션 로그, 스냅샷 |

**주요 RDBMS 제품:**

| 제품 | 특징 | 사용 사례 |
|------|------|----------|
| **MySQL** | 오픈소스, 웹 애플리케이션에 널리 사용 | 웹 서비스, 중소규모 시스템 |
| **PostgreSQL** | 오픈소스, 고급 기능 풍부, 확장성 좋음 | 복잡한 쿼리, 지리정보 시스템 |
| **Oracle** | 상용, 대기업에서 널리 사용, 안정성 | 금융, 대기업 핵심 시스템 |
| **SQL Server** | Microsoft 제품, Windows 환경에 최적화 | .NET 기반 시스템 |
| **SQLite** | 파일 기반, 설치 불필요, 임베디드 | 모바일 앱, 테스트 |

---

## 2. 관계형 데이터베이스

### 관계형 모델이란? ◑

**관계형 데이터베이스(RDBMS)**는 데이터를 **테이블(table)** 형태로 저장하고, 테이블 간의 **관계(relationship)**를 통해 데이터를 연결한다. 1970년 에드거 코드(Edgar Codd)가 제안한 관계형 모델에 기반한다.

```
[users 테이블]                      [orders 테이블]
┌────┬─────────┬───────────────┐   ┌────┬─────────┬────────┬───────┐
│ id │  name   │     email     │   │ id │ user_id │ amount │ date  │
├────┼─────────┼───────────────┤   ├────┼─────────┼────────┼───────┤
│  1 │ 김철수  │ kim@email.com │   │  1 │    1    │ 50000  │ 01-15 │
│  2 │ 이영희  │ lee@email.com │   │  2 │    1    │ 30000  │ 01-20 │
│  3 │ 박민수  │ park@email.com│   │  3 │    2    │ 25000  │ 01-22 │
└────┴─────────┴───────────────┘   └────┴─────────┴────────┴───────┘
                                           │
                                           │ 외래키(FK)로 연결
                                           ▼
                                    users.id를 참조
```

### 기본 용어

**테이블 (Table, 릴레이션)**

데이터를 저장하는 기본 단위이다. 행(row)과 열(column)으로 구성된 2차원 구조이다.

**행 (Row, 튜플, 레코드)**

테이블의 한 줄로, 하나의 데이터 항목을 나타낸다. 위 예시에서 `(1, 김철수, kim@email.com)`이 하나의 행이다.

**열 (Column, 속성, 필드)**

데이터의 속성을 나타낸다. `name`, `email` 등이 열이다. 각 열은 데이터 타입(VARCHAR, INT 등)을 가진다.

**기본키 (Primary Key, PK)**

각 행을 **고유하게 식별**하는 열이다. 중복되거나 NULL일 수 없다.

```sql
-- id 열이 기본키
CREATE TABLE users (
    id INT PRIMARY KEY,    -- 1, 2, 3 처럼 고유한 값
    name VARCHAR(100),
    email VARCHAR(255)
);
```

**외래키 (Foreign Key, FK)**

다른 테이블의 기본키를 참조하는 열이다. 테이블 간의 관계를 정의한다.

```sql
-- user_id가 외래키 (users 테이블의 id를 참조)
CREATE TABLE orders (
    id INT PRIMARY KEY,
    user_id INT,
    amount INT,
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

외래키를 통해 **참조 무결성**이 보장된다. 존재하지 않는 사용자의 주문을 생성할 수 없다.

### 테이블 간 관계 유형 ◑

**1:1 관계 (One-to-One)**

한 테이블의 한 행이 다른 테이블의 한 행과만 연결된다.

```
[users]                    [user_profiles]
┌────┬─────────┐          ┌────┬─────────┬───────────┐
│ id │  name   │          │ id │ user_id │   bio     │
├────┼─────────┤          ├────┼─────────┼───────────┤
│  1 │ 김철수  │◀────────▶│  1 │    1    │ 개발자... │
│  2 │ 이영희  │◀────────▶│  2 │    2    │ 디자이너..│
└────┴─────────┘          └────┴─────────┴───────────┘
```

**1:N 관계 (One-to-Many)**

가장 흔한 관계 유형이다. 한 사용자가 여러 주문을 할 수 있다.

```
[users]                    [orders]
┌────┬─────────┐          ┌────┬─────────┬────────┐
│ id │  name   │          │ id │ user_id │ amount │
├────┼─────────┤          ├────┼─────────┼────────┤
│  1 │ 김철수  │◀─────────│  1 │    1    │ 50000  │
│    │         │◀─────────│  2 │    1    │ 30000  │
│  2 │ 이영희  │◀─────────│  3 │    2    │ 25000  │
└────┴─────────┘          └────┴─────────┴────────┘
```

**N:M 관계 (Many-to-Many)**

중간 테이블(연결 테이블)을 통해 구현한다. 한 학생이 여러 강의를 수강하고, 한 강의에 여러 학생이 있는 경우이다.

```
[students]          [enrollments]           [courses]
┌────┬────────┐    ┌────────────┬───────────┐    ┌────┬─────────┐
│ id │  name  │    │ student_id │ course_id │    │ id │  title  │
├────┼────────┤    ├────────────┼───────────┤    ├────┼─────────┤
│  1 │ 김철수 │◀───│     1      │     1     │───▶│  1 │ 수학    │
│    │        │◀───│     1      │     2     │───▶│  2 │ 영어    │
│  2 │ 이영희 │◀───│     2      │     1     │    │    │         │
└────┴────────┘    └────────────┴───────────┘    └────┴─────────┘
```

---

## 3. SQL

### SQL이란? ◑

**SQL(Structured Query Language)**은 관계형 데이터베이스를 다루기 위한 표준 언어이다. 1970년대 IBM에서 개발되었으며, 대부분의 RDBMS에서 사용된다.

SQL은 **선언적(declarative)** 언어이다. "어떻게(how)" 데이터를 가져올지가 아니라 "무엇을(what)" 원하는지를 기술한다. 데이터를 가져오는 방법은 DBMS의 **쿼리 최적화기**가 결정한다.

### DDL (Data Definition Language)

데이터베이스의 **구조**를 정의하는 명령어이다.

```sql
-- 테이블 생성
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,  -- 자동 증가 기본키
    name VARCHAR(100) NOT NULL,         -- 필수 입력
    email VARCHAR(255) UNIQUE,          -- 중복 불가
    age INT DEFAULT 0,                  -- 기본값 설정
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 테이블 구조 변경
ALTER TABLE users ADD COLUMN phone VARCHAR(20);
ALTER TABLE users DROP COLUMN phone;
ALTER TABLE users MODIFY COLUMN name VARCHAR(200);

-- 테이블 삭제
DROP TABLE users;              -- 테이블 자체를 삭제
TRUNCATE TABLE users;          -- 데이터만 삭제 (구조는 유지)
```

### DML (Data Manipulation Language)

데이터를 **조작**하는 명령어이다.

**SELECT - 데이터 조회**

```sql
-- 기본 조회
SELECT * FROM users;                          -- 모든 열 조회
SELECT name, email FROM users;                -- 특정 열만 조회

-- 조건 조회
SELECT * FROM users WHERE age > 20;           -- 20세 초과
SELECT * FROM users WHERE age BETWEEN 20 AND 30;  -- 20~30세
SELECT * FROM users WHERE name LIKE '김%';    -- '김'으로 시작하는 이름
SELECT * FROM users WHERE email IS NULL;      -- 이메일이 없는 사용자

-- 정렬
SELECT * FROM users ORDER BY created_at DESC; -- 최신순
SELECT * FROM users ORDER BY age ASC, name DESC;

-- 집계 함수
SELECT COUNT(*) FROM users;                   -- 행 개수
SELECT AVG(age) FROM users;                   -- 평균 나이
SELECT MAX(age), MIN(age) FROM users;         -- 최대/최소 나이

-- 그룹화
SELECT age, COUNT(*) as count
FROM users
GROUP BY age
HAVING COUNT(*) > 5;                          -- 5명 이상인 나이대만

-- 중복 제거
SELECT DISTINCT age FROM users;

-- 결과 제한
SELECT * FROM users LIMIT 10;                 -- 상위 10개만
SELECT * FROM users LIMIT 10 OFFSET 20;       -- 21~30번째 행
```

**INSERT - 데이터 삽입**

```sql
-- 단일 행 삽입
INSERT INTO users (name, email, age)
VALUES ('김철수', 'kim@email.com', 25);

-- 여러 행 한 번에 삽입
INSERT INTO users (name, email, age) VALUES
    ('이영희', 'lee@email.com', 30),
    ('박민수', 'park@email.com', 28);
```

**UPDATE - 데이터 수정**

```sql
-- 특정 행 수정
UPDATE users SET age = 26 WHERE id = 1;

-- 여러 열 수정
UPDATE users SET name = '김철수', age = 27 WHERE id = 1;

-- 주의: WHERE 없으면 모든 행이 수정됨!
UPDATE users SET age = 0;  -- 위험! 모든 사용자의 나이가 0이 됨
```

**DELETE - 데이터 삭제**

```sql
-- 특정 행 삭제
DELETE FROM users WHERE id = 1;

-- 주의: WHERE 없으면 모든 행이 삭제됨!
DELETE FROM users;  -- 위험! 모든 데이터 삭제
```

### JOIN ◑

**JOIN**은 여러 테이블을 연결하여 데이터를 조회하는 방법이다. 관계형 데이터베이스의 핵심 기능이다.

```
예시 데이터:

[users]                      [orders]
┌────┬─────────┐            ┌────┬─────────┬────────┐
│ id │  name   │            │ id │ user_id │ amount │
├────┼─────────┤            ├────┼─────────┼────────┤
│  1 │ 김철수  │            │  1 │    1    │ 50000  │
│  2 │ 이영희  │            │  2 │    1    │ 30000  │
│  3 │ 박민수  │            │  3 │    4    │ 25000  │ ← user_id=4는 users에 없음
└────┴─────────┘            └────┴─────────┴────────┘
```

**INNER JOIN - 양쪽에 모두 있는 데이터만**

```sql
SELECT users.name, orders.amount
FROM users
INNER JOIN orders ON users.id = orders.user_id;

-- 결과: 김철수-50000, 김철수-30000
-- (이영희는 주문 없음, user_id=4는 사용자 없음 → 제외)
```

```
[users]          ∩         [orders]
  1 ────────────────────── 1 (user_id=1)
  1 ────────────────────── 2 (user_id=1)
  2 (주문 없음)
  3 (주문 없음)
                           3 (user_id=4, 사용자 없음)
```

**LEFT JOIN - 왼쪽 테이블은 전부, 오른쪽은 일치하는 것만**

```sql
SELECT users.name, orders.amount
FROM users
LEFT JOIN orders ON users.id = orders.user_id;

-- 결과:
-- 김철수-50000, 김철수-30000 (일치)
-- 이영희-NULL (주문 없음)
-- 박민수-NULL (주문 없음)
```

주문이 없는 사용자도 결과에 포함되며, orders 관련 열은 NULL이 된다.

**RIGHT JOIN - 오른쪽 테이블은 전부**

```sql
SELECT users.name, orders.amount
FROM users
RIGHT JOIN orders ON users.id = orders.user_id;

-- 결과:
-- 김철수-50000, 김철수-30000 (일치)
-- NULL-25000 (user_id=4의 사용자가 없음)
```

**FULL OUTER JOIN - 양쪽 모두 전부**

```sql
SELECT users.name, orders.amount
FROM users
FULL OUTER JOIN orders ON users.id = orders.user_id;

-- 결과: 양쪽 모든 데이터 포함, 일치하지 않으면 NULL
```

> MySQL은 FULL OUTER JOIN을 직접 지원하지 않아 LEFT JOIN과 RIGHT JOIN을 UNION해야 한다.

**JOIN 요약:**

```
┌────────────────────────────────────────────────────────────────────┐
│                           JOIN 비교                                │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│   INNER JOIN          LEFT JOIN           RIGHT JOIN              │
│   ┌───┬───┐          ┌───┬───┐          ┌───┬───┐               │
│   │   │███│          │███│███│          │███│   │               │
│   │   │███│          │███│███│          │███│   │               │
│   │   │   │          │███│   │          │   │   │               │
│   └───┴───┘          └───┴───┘          └───┴───┘               │
│   교집합만            왼쪽 전체 +         오른쪽 전체 +            │
│                       교집합              교집합                   │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

---

## 4. 인덱스

### ⭕ 인덱스란 무엇이고, 장단점은?

**인덱스(Index)**는 데이터를 빠르게 검색하기 위한 **자료구조**이다. 책의 색인(찾아보기)과 같은 역할을 한다.

```
인덱스 없이 검색 (Full Table Scan):
┌────┬─────────┬────────┐
│ id │  name   │  age   │
├────┼─────────┼────────┤
│  1 │ 김철수  │   25   │  ← 확인
│  2 │ 이영희  │   30   │  ← 확인
│  3 │ 박민수  │   28   │  ← 확인
│ ...│  ...    │  ...   │  ← 모든 행을 순차적으로 확인해야 함
│ 1M │ 최지우  │   22   │  ← 100만 번째 행까지...
└────┴─────────┴────────┘

SELECT * FROM users WHERE name = '최지우';
→ 최악의 경우 100만 행을 모두 확인해야 함 (O(n))


인덱스로 검색 (Index Scan):
[name 인덱스]                     [실제 데이터]
┌─────────┬─────────┐            ┌────┬─────────┐
│  name   │  위치    │            │ id │  name   │
├─────────┼─────────┤            ├────┼─────────┤
│ 김OO... │ → 블록1  │            │    │         │
│ 박OO... │ → 블록5  │            │    │         │
│ 이OO... │ → 블록3  │            │    │         │
│ 최지우  │ → 블록99 │ ─────────▶│ 1M │ 최지우  │
└─────────┴─────────┘            └────┴─────────┘

→ B-Tree 탐색으로 빠르게 찾음 (O(log n))
```

**인덱스의 장점:**
- 검색 속도 대폭 향상 (O(n) → O(log n))
- ORDER BY, GROUP BY 성능 향상
- 범위 검색(BETWEEN, >, <) 효율화

**인덱스의 단점:**
- **추가 저장 공간 필요**: 인덱스도 데이터이므로 디스크 공간 사용
- **쓰기 성능 저하**: INSERT, UPDATE, DELETE 시 인덱스도 갱신해야 함
- **너무 많은 인덱스는 오히려 해로움**: 쓰기 성능 저하, 최적화기 혼란

**인덱스를 만들어야 하는 경우:**
- WHERE 절에서 자주 사용되는 열
- JOIN 조건에 사용되는 열 (외래키)
- ORDER BY, GROUP BY에 사용되는 열

**인덱스를 피해야 하는 경우:**
- 데이터가 자주 변경되는 열
- 값의 종류가 적은 열 (성별처럼 M/F만 있는 경우)
- 테이블의 데이터가 적은 경우

```sql
-- 인덱스 생성
CREATE INDEX idx_users_name ON users(name);

-- 복합 인덱스 (여러 열을 하나의 인덱스로)
CREATE INDEX idx_users_name_age ON users(name, age);

-- 인덱스 삭제
DROP INDEX idx_users_name ON users;

-- 인덱스 확인
SHOW INDEX FROM users;
```

### 인덱스 자료구조 ◑

**B-Tree (Balanced Tree)**

가장 일반적인 인덱스 자료구조이다. **균형 트리**로, 모든 리프 노드가 같은 깊이에 있다.

```
                    ┌─────────────────┐
                    │    [M]          │  ← 루트 노드
                    └────────┬────────┘
                             │
            ┌────────────────┼────────────────┐
            ▼                ▼                ▼
     ┌──────────┐     ┌──────────┐     ┌──────────┐
     │ [D, H]   │     │ [P, T]   │     │ [X]      │  ← 내부 노드
     └────┬─────┘     └────┬─────┘     └────┬─────┘
          │                │                │
    ┌─────┼─────┐    ┌─────┼─────┐    ┌─────┼─────┐
    ▼     ▼     ▼    ▼     ▼     ▼    ▼     ▼     ▼
  [A,C] [E,G] [I,L] [N,O] [Q,S] [U,W] [Y,Z]        ← 리프 노드 (실제 데이터)
```

- 검색, 삽입, 삭제 모두 O(log n)
- 범위 검색 가능 (BETWEEN, >, <)
- 대부분의 DBMS에서 기본 인덱스로 사용

**B+Tree**

B-Tree의 변형으로, **리프 노드에만 실제 데이터**가 있고 **리프 노드끼리 연결**되어 있다.

```
                    ┌─────────────────┐
                    │    [M]          │  ← 루트 (키만 저장)
                    └────────┬────────┘
                             │
            ┌────────────────┼────────────────┐
            ▼                ▼                ▼
     ┌──────────┐     ┌──────────┐     ┌──────────┐
     │ [D, H]   │     │ [P, T]   │     │ [X]      │  ← 내부 노드 (키만)
     └────┬─────┘     └────┬─────┘     └────┬─────┘
          │                │                │
          ▼                ▼                ▼
  [A,C,D]──▶[E,G,H]──▶[I,L,M]──▶[N,O,P]──▶[Q,S,T]──▶[U,W,X]──▶[Y,Z]
  ↑                                                              ↑
  └──────────────── 리프 노드끼리 연결됨 ─────────────────────────┘
```

**B+Tree가 RDBMS에서 선호되는 이유:**
- 리프 노드가 연결되어 있어 **범위 검색이 매우 빠름**
- 내부 노드에는 키만 저장하므로 한 노드에 더 많은 키를 저장할 수 있음
- 모든 데이터가 리프 노드에만 있어 검색 경로가 일정함

**Hash Index**

해시 함수를 사용하여 O(1)에 데이터를 찾는다.

```
해시 함수: hash("김철수") = 3

┌────────┬─────────────┐
│ 해시값  │    데이터    │
├────────┼─────────────┤
│   0    │ → 박민수    │
│   1    │ → (비어있음) │
│   2    │ → 이영희    │
│   3    │ → 김철수    │ ← hash("김철수") = 3
│  ...   │    ...      │
└────────┴─────────────┘
```

- 동등 비교(=)는 O(1)으로 매우 빠름
- **범위 검색 불가** (>, <, BETWEEN)
- ORDER BY에 사용 불가
- 메모리 기반 테이블이나 특수한 경우에만 사용

### 클러스터드 vs 논클러스터드 인덱스 ◑

**클러스터드 인덱스 (Clustered Index)**

테이블의 **실제 데이터가 인덱스 순서대로 정렬**되어 저장된다. 사전에서 단어가 알파벳 순서로 정렬되어 있는 것과 같다.

```
[클러스터드 인덱스 (id 기준)]

인덱스와 데이터가 함께 저장됨:
┌────┬─────────┬────────┐
│ id │  name   │  age   │  ← 데이터가 id 순서로 물리적 정렬
├────┼─────────┼────────┤
│  1 │ 김철수  │   25   │
│  2 │ 이영희  │   30   │
│  3 │ 박민수  │   28   │
│  4 │ 최지우  │   22   │
└────┴─────────┴────────┘
```

- 테이블당 **1개만 가능** (데이터 자체가 정렬되므로)
- 기본키에 자동 생성됨
- **범위 검색이 빠름** (데이터가 연속으로 저장되어 있으므로)

**논클러스터드 인덱스 (Non-clustered Index)**

**별도의 인덱스 구조**를 만들고, 실제 데이터 위치를 포인터로 가리킨다. 책 뒤의 색인(찾아보기)과 같다.

```
[논클러스터드 인덱스 (name 기준)]

인덱스 (별도 저장):               실제 데이터:
┌─────────┬─────────┐            ┌────┬─────────┐
│  name   │ 포인터   │            │ id │  name   │
├─────────┼─────────┤            ├────┼─────────┤
│ 김철수  │ → row1  │ ─────────▶ │  1 │ 김철수  │
│ 박민수  │ → row3  │ ─────────▶ │  3 │ 박민수  │
│ 이영희  │ → row2  │ ─────────▶ │  2 │ 이영희  │
│ 최지우  │ → row4  │ ─────────▶ │  4 │ 최지우  │
└─────────┴─────────┘            └────┴─────────┘
```

- 테이블당 **여러 개 가능**
- 인덱스 검색 후 포인터를 따라가야 하므로 한 번 더 접근 필요
- 단일 검색에 적합

| 구분 | 클러스터드 | 논클러스터드 |
|------|-----------|-------------|
| 데이터 정렬 | 인덱스 순서로 물리적 정렬 | 별도 저장 |
| 테이블당 개수 | 1개만 가능 | 여러 개 가능 |
| 범위 검색 | 빠름 (연속 저장) | 상대적으로 느림 |
| 단일 검색 | 보통 | 빠름 |
| 추가 공간 | 불필요 | 인덱스 저장 공간 필요 |

---

## 5. 트랜잭션

### ⭕ 트랜잭션이란? ◑

**트랜잭션(Transaction)**은 데이터베이스 상태를 변화시키는 **하나의 논리적인 작업 단위**이다. 여러 개의 SQL 문을 하나로 묶어서 **전부 성공하거나 전부 실패**하도록 보장한다.

```
[계좌 이체 예시]

A 계좌 → B 계좌로 10만원 이체

BEGIN TRANSACTION;
  UPDATE accounts SET balance = balance - 100000 WHERE id = 'A';  -- A 출금
  UPDATE accounts SET balance = balance + 100000 WHERE id = 'B';  -- B 입금
COMMIT;

문제 상황: A에서 출금 후 시스템 장애 발생
- A 잔액: 900,000원 (출금됨)
- B 잔액: 500,000원 (입금 안 됨)
→ 10만원이 사라짐!

트랜잭션이 해결:
- 두 작업이 모두 성공해야 COMMIT
- 하나라도 실패하면 ROLLBACK (A 잔액도 원래대로)
```

### ⭕ ACID를 설명하라

트랜잭션이 보장해야 하는 4가지 특성이다.

**Atomicity (원자성)**

트랜잭션의 모든 작업이 **전부 수행되거나 전혀 수행되지 않아야** 한다. "All or Nothing"이다.

```
BEGIN;
  INSERT INTO orders (id, amount) VALUES (1, 50000);  -- 성공
  UPDATE inventory SET stock = stock - 1 WHERE id = 10;  -- 실패! (재고 부족)
ROLLBACK;  -- 주문 INSERT도 취소됨
```

**Consistency (일관성)**

트랜잭션 전후로 데이터베이스는 **일관된 상태**를 유지해야 한다. 모든 제약 조건(외래키, UNIQUE 등)이 만족되어야 한다.

```
-- 계좌 이체 전: A(1,000,000) + B(500,000) = 1,500,000원
-- 계좌 이체 후: A(900,000) + B(600,000) = 1,500,000원
-- 총액이 유지됨 = 일관성 보장
```

**Isolation (격리성)**

동시에 실행되는 트랜잭션들이 **서로 영향을 미치지 않아야** 한다. 마치 순차적으로 실행된 것처럼 보여야 한다.

```
T1: A 계좌 → B 계좌 이체
T2: B 계좌 잔액 조회

T2가 T1이 완료되기 전에 B 잔액을 조회하면?
→ 격리 수준에 따라 결과가 달라짐
```

**Durability (지속성)**

**완료(COMMIT)된 트랜잭션의 결과는 영구적**으로 저장되어야 한다. 시스템 장애가 발생해도 유지된다.

```
COMMIT 완료 후 서버 다운

→ 재시작 후에도 COMMIT된 데이터는 보존됨
→ 트랜잭션 로그(WAL)를 통해 복구
```

### 트랜잭션 격리 수준 ◑

격리성을 어느 정도로 보장할지 결정하는 수준이다. 격리 수준이 높을수록 안전하지만 성능이 저하된다.

**발생할 수 있는 문제들:**

**Dirty Read (더티 리드)**

다른 트랜잭션이 **커밋하지 않은 데이터**를 읽는 문제이다.

```
T1: UPDATE balance = 0 (아직 COMMIT 안 함)
T2: SELECT balance → 0 반환 (T1의 변경을 읽음)
T1: ROLLBACK → balance는 원래값으로 복원

T2가 읽은 0은 실제로 존재한 적 없는 값!
```

**Non-Repeatable Read (반복 불가능한 읽기)**

같은 쿼리를 두 번 실행했는데 **결과가 다른** 문제이다.

```
T1: SELECT balance → 1000
T2: UPDATE balance = 500; COMMIT
T1: SELECT balance → 500 (아까랑 다름!)

T1 입장에서 같은 쿼리 결과가 달라짐
```

**Phantom Read (팬텀 리드)**

같은 조건으로 조회했는데 **행의 개수가 달라지는** 문제이다.

```
T1: SELECT COUNT(*) WHERE age > 20 → 5개
T2: INSERT INTO users (age=25); COMMIT
T1: SELECT COUNT(*) WHERE age > 20 → 6개 (유령처럼 행이 나타남!)
```

**격리 수준별 문제 발생 여부:**

| 격리 수준 | Dirty Read | Non-Repeatable Read | Phantom Read | 성능 |
|-----------|------------|---------------------|--------------|------|
| READ UNCOMMITTED | 발생 | 발생 | 발생 | 가장 빠름 |
| READ COMMITTED | 방지 | 발생 | 발생 | 빠름 |
| REPEATABLE READ | 방지 | 방지 | 발생 | 보통 |
| SERIALIZABLE | 방지 | 방지 | 방지 | 느림 |

대부분의 DBMS 기본값은 **READ COMMITTED**(Oracle, SQL Server) 또는 **REPEATABLE READ**(MySQL)이다.

### ⭕ 데이터베이스 락(Lock)이란? ◑

**락(Lock)**은 동시성 제어를 위해 데이터 접근을 제한하는 메커니즘이다. 여러 트랜잭션이 동시에 같은 데이터를 수정하는 것을 방지한다.

**Shared Lock (S Lock, 공유 락)**

데이터를 **읽을 때** 사용한다. 여러 트랜잭션이 동시에 Shared Lock을 가질 수 있다.

```
T1: SELECT * FROM users WHERE id = 1;  -- S Lock 획득
T2: SELECT * FROM users WHERE id = 1;  -- S Lock 획득 (동시 읽기 가능)
T3: UPDATE users SET name = 'X' WHERE id = 1;  -- 대기! (S Lock이 해제될 때까지)
```

**Exclusive Lock (X Lock, 배타 락)**

데이터를 **수정할 때** 사용한다. 다른 어떤 락과도 호환되지 않는다.

```
T1: UPDATE users SET name = 'A' WHERE id = 1;  -- X Lock 획득
T2: SELECT * FROM users WHERE id = 1;  -- 대기! (X Lock 해제까지)
T3: UPDATE users SET name = 'B' WHERE id = 1;  -- 대기!
```

**락 호환성:**

|  | S Lock | X Lock |
|--|--------|--------|
| **S Lock** | 호환 | 충돌 |
| **X Lock** | 충돌 | 충돌 |

**데드락 (Deadlock)**

두 트랜잭션이 서로가 가진 락을 기다리며 무한 대기하는 상태이다.

```
T1: UPDATE accounts SET balance = balance - 100 WHERE id = 'A';  -- A에 X Lock
T2: UPDATE accounts SET balance = balance - 100 WHERE id = 'B';  -- B에 X Lock

T1: UPDATE accounts SET balance = balance + 100 WHERE id = 'B';  -- B 락 대기
T2: UPDATE accounts SET balance = balance + 100 WHERE id = 'A';  -- A 락 대기

→ T1은 T2를 기다리고, T2는 T1을 기다림 = 데드락!
```

DBMS는 데드락을 감지하면 하나의 트랜잭션을 강제 롤백한다.

### ⭕ 낙관적 락과 비관적 락의 차이는? ◑

**비관적 락 (Pessimistic Locking)**

충돌이 **발생할 것이라고 가정**하고, 데이터를 읽을 때부터 락을 건다.

```sql
-- 읽는 순간 락 획득
SELECT * FROM products WHERE id = 1 FOR UPDATE;

-- 다른 트랜잭션은 이 행에 접근 불가
UPDATE products SET stock = stock - 1 WHERE id = 1;

COMMIT;  -- 락 해제
```

- 충돌이 많은 환경에 적합
- 데이터 정합성 확실히 보장
- 락 대기로 인한 성능 저하

**낙관적 락 (Optimistic Locking)**

충돌이 **발생하지 않을 것이라고 가정**하고, 커밋할 때만 충돌을 확인한다. 주로 **버전 번호**를 사용한다.

```sql
-- 테이블에 version 열 추가
-- products: (id, name, stock, version)

-- 1. 데이터 조회 (락 없음)
SELECT * FROM products WHERE id = 1;
-- 결과: id=1, stock=10, version=1

-- 2. 업데이트 시 version 확인
UPDATE products
SET stock = stock - 1, version = version + 1
WHERE id = 1 AND version = 1;  -- 조회 시점의 version과 비교

-- 3. 만약 다른 트랜잭션이 이미 수정했다면?
-- version이 2가 되어 있어서 WHERE 조건 불일치 → 0 rows updated
-- → 애플리케이션에서 재시도
```

| 구분 | 낙관적 락 | 비관적 락 |
|------|-----------|-----------|
| 가정 | 충돌이 거의 없음 | 충돌이 자주 발생 |
| 방식 | 버전/타임스탬프로 커밋 시 검사 | 조회 시점에 락 획득 |
| 충돌 시 | 롤백 후 재시도 | 락 해제 대기 |
| 적합한 경우 | 읽기 위주, 충돌 적음 | 쓰기 위주, 충돌 많음 |
| 성능 | 충돌 없으면 빠름 | 락 대기로 느릴 수 있음 |

---

## 6. 정규화

### ⭕ 정규화란 무엇인가?

**정규화(Normalization)**는 데이터 **중복을 최소화**하고 **무결성을 유지**하기 위해 테이블을 분해하는 과정이다.

**왜 정규화가 필요한가?**

```
[정규화되지 않은 테이블 - 주문]
┌────┬─────────┬──────────────┬─────────┬──────────┐
│ id │ 고객명   │ 고객전화      │ 상품명   │ 가격      │
├────┼─────────┼──────────────┼─────────┼──────────┤
│  1 │ 김철수  │ 010-1234-5678│ 노트북  │ 1,500,000│
│  2 │ 김철수  │ 010-1234-5678│ 마우스  │    30,000│
│  3 │ 이영희  │ 010-9876-5432│ 키보드  │    50,000│
└────┴─────────┴──────────────┴─────────┴──────────┘

문제점:
1. 데이터 중복: 김철수의 전화번호가 2번 저장됨
2. 갱신 이상: 김철수 전화번호 변경 시 2개 행을 모두 수정해야 함
3. 삽입 이상: 주문 없이 고객 정보만 저장 불가
4. 삭제 이상: 주문 삭제 시 고객 정보도 사라질 수 있음
```

### 정규형 ◑

**제1정규형 (1NF)**

모든 열이 **원자값(Atomic Value)**만 포함해야 한다. 하나의 셀에 여러 값이 들어가면 안 된다.

```
[1NF 위반]                              [1NF 만족]
┌────┬──────────────────┐              ┌────┬──────────┐
│ id │ 전화번호          │              │ id │ 전화번호  │
├────┼──────────────────┤              ├────┼──────────┤
│  1 │ 010-1234, 02-555 │  ──────▶    │  1 │ 010-1234 │
│    │ (다중값!)         │              │  1 │ 02-555   │
└────┴──────────────────┘              └────┴──────────┘
```

**제2정규형 (2NF)**

1NF를 만족하고, 모든 비주요 속성이 기본키 **전체**에 종속되어야 한다. **부분 함수 종속 제거**이다.

```
[2NF 위반 - 복합키 (학생ID, 과목ID)]
┌─────────┬─────────┬──────────┬─────────┐
│ 학생ID  │ 과목ID  │ 학생이름  │ 점수     │
├─────────┼─────────┼──────────┼─────────┤
│ 1       │ 101     │ 김철수   │ 90      │
│ 1       │ 102     │ 김철수   │ 85      │  ← 학생이름이 학생ID에만 종속
│ 2       │ 101     │ 이영희   │ 95      │    (과목ID와 무관)
└─────────┴─────────┴──────────┴─────────┘

[2NF 만족]
┌─────────┬──────────┐    ┌─────────┬─────────┬─────────┐
│ 학생ID  │ 학생이름  │    │ 학생ID  │ 과목ID  │ 점수     │
├─────────┼──────────┤    ├─────────┼─────────┼─────────┤
│ 1       │ 김철수   │    │ 1       │ 101     │ 90      │
│ 2       │ 이영희   │    │ 1       │ 102     │ 85      │
└─────────┴──────────┘    │ 2       │ 101     │ 95      │
                          └─────────┴─────────┴─────────┘
```

**제3정규형 (3NF)**

2NF를 만족하고, **이행적 함수 종속이 없어야** 한다. A→B, B→C일 때 A→C가 되면 안 된다.

```
[3NF 위반]
┌─────────┬──────────┬──────────┐
│ 학생ID  │ 학과      │ 학과장    │
├─────────┼──────────┼──────────┤
│ 1       │ 컴퓨터   │ 김교수   │  ← 학생ID → 학과 → 학과장
│ 2       │ 컴퓨터   │ 김교수   │    (이행적 종속)
│ 3       │ 경영     │ 이교수   │
└─────────┴──────────┴──────────┘

[3NF 만족]
┌─────────┬──────────┐    ┌──────────┬──────────┐
│ 학생ID  │ 학과      │    │ 학과      │ 학과장    │
├─────────┼──────────┤    ├──────────┼──────────┤
│ 1       │ 컴퓨터   │    │ 컴퓨터   │ 김교수   │
│ 2       │ 컴퓨터   │    │ 경영     │ 이교수   │
│ 3       │ 경영     │    └──────────┴──────────┘
└─────────┴──────────┘
```

**BCNF (Boyce-Codd Normal Form)**

3NF를 만족하고, **모든 결정자가 후보키**여야 한다. 3NF보다 엄격한 조건이다.

### 반정규화 ◑

**반정규화(Denormalization)**는 성능 향상을 위해 **의도적으로 정규화 규칙을 위반**하는 것이다.

```
정규화된 상태:
- 주문 조회 시 고객 테이블, 상품 테이블, 배송 테이블을 JOIN해야 함
- JOIN이 많으면 성능 저하

반정규화:
- 자주 사용하는 고객명, 상품명을 주문 테이블에 중복 저장
- JOIN 없이 바로 조회 가능
- 단, 데이터 불일치 위험 있음
```

**언제 반정규화하는가?**
- 조회 성능이 매우 중요한 경우
- JOIN이 너무 많아 쿼리가 복잡해지는 경우
- 읽기가 쓰기보다 훨씬 많은 경우

---

## 7. NoSQL

### ⭕ SQL과 NoSQL의 차이는?

**NoSQL**은 "Not Only SQL"의 약자로, 관계형 모델이 아닌 다양한 데이터 모델을 지원하는 데이터베이스이다.

**왜 NoSQL이 등장했는가?**

2000년대 후반 빅데이터, SNS, IoT 등의 등장으로 기존 RDBMS의 한계가 드러났다.

```
RDBMS의 한계:
- 수평적 확장(Scale-out) 어려움
- 스키마 변경이 어려움
- 비정형 데이터 저장에 부적합
- 대용량 데이터에서 JOIN 성능 저하

NoSQL의 등장:
- 대용량 데이터 처리
- 유연한 스키마
- 수평적 확장 용이
- 다양한 데이터 모델
```

### SQL vs NoSQL 비교 ◑

| 구분 | SQL (RDBMS) | NoSQL |
|------|-------------|-------|
| 데이터 모델 | 테이블 (행, 열) | 문서, 키-값, 그래프 등 다양 |
| 스키마 | 고정 스키마 (미리 정의) | 유연한 스키마 (동적) |
| 확장 방식 | **수직적 확장** (더 좋은 서버) | **수평적 확장** (서버 추가) |
| JOIN | 강력한 JOIN 지원 | 제한적 또는 미지원 |
| 트랜잭션 | **ACID** 보장 | **BASE** (보통) |
| 적합한 경우 | 복잡한 쿼리, 트랜잭션 중요 | 대용량, 빠른 개발, 비정형 데이터 |

**ACID vs BASE:**

```
ACID (RDBMS)
- Atomicity: 원자성
- Consistency: 일관성
- Isolation: 격리성
- Durability: 지속성
→ 강한 일관성 보장

BASE (NoSQL)
- Basically Available: 기본적인 가용성
- Soft state: 일시적 불일치 허용
- Eventual consistency: 최종적 일관성
→ 가용성과 성능 우선, 일관성은 나중에
```

### CAP 정리 ◑

분산 시스템에서 **세 가지 특성을 동시에 만족할 수 없다**는 정리이다.

```
        Consistency (일관성)
              /\
             /  \
            /    \
           /  CA  \
          /________\
         /\        /\
        /  \  CP  /  \
       / AP \    /    \
      /______\  /______\
Availability    Partition Tolerance
 (가용성)         (분할 내성)
```

- **C (Consistency)**: 모든 노드가 같은 데이터를 봄
- **A (Availability)**: 항상 응답을 받을 수 있음
- **P (Partition Tolerance)**: 네트워크 분리에도 동작

**네트워크 파티션**은 분산 시스템에서 피할 수 없으므로 실제로는 **CP** 또는 **AP** 중 선택한다.

| 유형 | 설명 | 예시 |
|------|------|------|
| **CP** | 일관성 우선, 가용성 포기 | MongoDB, HBase |
| **AP** | 가용성 우선, 일관성 포기 | Cassandra, DynamoDB |

### NoSQL 유형 ◑

**Key-Value Store**

가장 단순한 형태로, **키로 값을 저장하고 조회**한다. 값의 내용은 DB가 관여하지 않는다.

```
┌──────────────────┬──────────────────────────┐
│       Key        │          Value           │
├──────────────────┼──────────────────────────┤
│ user:1001        │ {"name": "김철수", ...}  │
│ session:abc123   │ {"userId": 1001, ...}    │
│ cache:product:1  │ {"name": "노트북", ...}  │
└──────────────────┴──────────────────────────┘
```

- **예시**: Redis, DynamoDB, Memcached
- **적합한 경우**: 세션 저장, 캐싱, 실시간 데이터

**Document Store**

**JSON 형태의 문서**를 저장한다. 문서 내 필드로 쿼리할 수 있다.

```json
// MongoDB 문서 예시
{
  "_id": "507f1f77bcf86cd799439011",
  "name": "김철수",
  "email": "kim@email.com",
  "orders": [
    { "product": "노트북", "amount": 1500000 },
    { "product": "마우스", "amount": 30000 }
  ]
}
// 중첩 구조로 관련 데이터를 한 문서에 저장 (JOIN 불필요)
```

- **예시**: MongoDB, CouchDB
- **적합한 경우**: 유연한 스키마 필요, 문서 중심 데이터

**Column-Family Store**

**열 기반**으로 데이터를 저장한다. 같은 열의 데이터가 연속으로 저장되어 집계 쿼리에 효율적이다.

```
행 기반 저장 (RDBMS):
Row1: [id:1, name:김철수, age:25]
Row2: [id:2, name:이영희, age:30]
Row3: [id:3, name:박민수, age:28]

열 기반 저장 (Column-Family):
id:    [1, 2, 3]
name:  [김철수, 이영희, 박민수]
age:   [25, 30, 28]

→ age의 평균을 구할 때 age 열만 읽으면 됨
```

- **예시**: Cassandra, HBase, ClickHouse
- **적합한 경우**: 대용량 분석, 시계열 데이터, 로그

**Graph Database**

**노드와 엣지**로 관계를 표현한다. 관계가 복잡한 데이터에 적합하다.

```
      ┌─────────┐
      │ 김철수  │
      └────┬────┘
           │ 친구
    ┌──────┴──────┐
    ▼             ▼
┌─────────┐  ┌─────────┐
│ 이영희  │──│ 박민수  │
└─────────┘  └─────────┘
     친구

"김철수의 친구의 친구 찾기" 같은 쿼리에 효율적
```

- **예시**: Neo4j, Amazon Neptune
- **적합한 경우**: 소셜 네트워크, 추천 시스템, 지식 그래프

---

## 면접 대비 체크리스트 ◑

- [ ] DBMS의 역할과 주요 기능 (DDL, DML, DCL)
- [ ] 기본키, 외래키 개념과 참조 무결성
- [ ] 테이블 관계 유형 (1:1, 1:N, N:M)
- [ ] JOIN 종류와 차이 (INNER, LEFT, RIGHT, FULL)
- [ ] 인덱스 동작 원리와 장단점
- [ ] B-Tree vs B+Tree 차이
- [ ] 클러스터드 vs 논클러스터드 인덱스
- [ ] 트랜잭션과 ACID 속성
- [ ] 트랜잭션 격리 수준과 문제 (Dirty Read, Phantom Read 등)
- [ ] Shared Lock vs Exclusive Lock
- [ ] 낙관적 락 vs 비관적 락
- [ ] 데드락이란?
- [ ] 정규화와 정규형 (1NF, 2NF, 3NF)
- [ ] 반정규화를 하는 이유
- [ ] SQL vs NoSQL 차이
- [ ] CAP 정리
- [ ] NoSQL 유형별 특징과 사용 사례
