# 00. 컴퓨터 공학 기초 (CS Fundamentals) ◑

---

## 1. 프로그래밍의 역사 ◑

### 주요 마일스톤 ◑

| 연도 | 사건 |
|------|------|
| 1842 | Ada Lovelace, 최초의 알고리즘 작성 (Babbage의 해석기관) |
| 1940s | 최초의 전자식 컴퓨터 (ENIAC), 기계어 프로그래밍 |
| 1950s | FORTRAN (1957), 최초의 고급 언어 |
| 1958 | LISP (함수형), ALGOL (구조적 프로그래밍의 시초) |
| 1964 | BASIC, 교육용 언어 |
| 1972 | **C 언어** (Dennis Ritchie, Bell Labs) - Unix와 함께 발전 |
| 1983 | **C++** (Bjarne Stroustrup) - C with Classes에서 발전 |
| 1980s | Smalltalk (순수 객체지향), Perl |
| 1991 | **Python** (Guido van Rossum) |
| 1995 | **Java**, **JavaScript**, PHP, Ruby |
| 2000s | C#, Scala, Go, Rust |
| 2010s | Swift, Kotlin, TypeScript |

### 프로그래밍 패러다임의 발전 ◑

```
절차적 (Procedural)
    → 구조적 (Structured)
        → 객체지향 (OOP)
            → 함수형 (Functional)
                → 반응형 (Reactive)
```

| 패러다임 | 특징 | 대표 언어 |
|----------|------|----------|
| **절차적** | 순차적 명령어 실행 | C, Pascal |
| **객체지향** | 객체와 메시지 | Java, C++, Python |
| **함수형** | 순수 함수, 불변성 | Haskell, Lisp, Scala |
| **논리형** | 규칙과 사실 기반 | Prolog |

---

## 2. 소프트웨어 계층 구조 ◑

### ⭕ 펌웨어, 미들웨어, 드라이버의 차이는?

```
┌─────────────────────────────────────┐
│         응용 프로그램 (Application)    │
├─────────────────────────────────────┤
│           미들웨어 (Middleware)        │  ← 애플리케이션 간 연결
├─────────────────────────────────────┤
│         운영체제 (Operating System)    │
├─────────────────────────────────────┤
│            드라이버 (Driver)           │  ← 하드웨어 제어
├─────────────────────────────────────┤
│           펌웨어 (Firmware)            │  ← 하드웨어 내장 소프트웨어
├─────────────────────────────────────┤
│           하드웨어 (Hardware)          │
└─────────────────────────────────────┘
```

| 개념 | 설명 | 예시 |
|------|------|------|
| **펌웨어** | 하드웨어에 내장된 소프트웨어, ROM/Flash에 저장 | BIOS/UEFI, 라우터 펌웨어, 임베디드 시스템 |
| **드라이버** | OS와 하드웨어 간 인터페이스 | 그래픽 드라이버, 프린터 드라이버 |
| **미들웨어** | 애플리케이션과 OS/네트워크 사이 연결 | 메시지 큐, 웹 서버, ORM |

### 펌웨어 vs 소프트웨어 ◑

| 구분 | 펌웨어 | 소프트웨어 |
|------|--------|-----------|
| 저장 위치 | ROM, Flash | RAM, 저장장치 |
| 수정 | 어려움 (특별한 절차) | 쉬움 |
| 목적 | 특정 하드웨어 제어 | 범용 작업 수행 |
| 예시 | BIOS, SSD 컨트롤러 | Word, Chrome |

---

## 3. 개발 도구의 종류 ◑

### ⭕ 라이브러리, 프레임워크, SDK, API의 차이는?

| 개념 | 설명 | 제어권 | 예시 |
|------|------|--------|------|
| **라이브러리** | 재사용 가능한 코드 모음 | 개발자 | lodash, NumPy |
| **프레임워크** | 애플리케이션 구조를 제공 | 프레임워크 (IoC) | Spring, Django, Angular |
| **SDK** | 특정 플랫폼 개발 도구 세트 | - | Android SDK, iOS SDK |
| **API** | 소프트웨어 간 상호작용 인터페이스 | - | REST API, Windows API |

### IoC (Inversion of Control) ◑

프레임워크와 라이브러리의 핵심 차이:

```
라이브러리: 개발자가 라이브러리를 호출
프레임워크: 프레임워크가 개발자 코드를 호출 (Hollywood Principle: "Don't call us, we'll call you")
```

```python
# 라이브러리 사용: 내가 필요할 때 호출
import requests
response = requests.get("https://api.example.com")  # 내가 호출

# 프레임워크 사용: 프레임워크가 내 코드를 호출
@app.route("/users")  # Flask가 요청 시 이 함수를 호출함
def get_users():
    return users
```

### SDK 구성 요소 ◑

| 구성 요소 | 설명 |
|-----------|------|
| 라이브러리 | 플랫폼 기능 제공 |
| 컴파일러/빌드 도구 | 코드 빌드 |
| 디버거 | 디버깅 지원 |
| 에뮬레이터/시뮬레이터 | 테스트 환경 |
| 문서 | API 레퍼런스 |
| 샘플 코드 | 예제 |

### 플랫폼 (Platform) ◑

| 플랫폼 유형 | 설명 | 예시 |
|-------------|------|------|
| **하드웨어 플랫폼** | 물리적 컴퓨팅 환경 | x86, ARM |
| **OS 플랫폼** | 운영체제 | Windows, Linux, macOS |
| **런타임 플랫폼** | 실행 환경 | JVM, .NET CLR, Node.js |
| **클라우드 플랫폼** | 클라우드 서비스 | AWS, GCP, Azure |

---

## 4. 컴파일러 vs 인터프리터 ◑

### ⭕ 컴파일러와 인터프리터의 차이는?

| 구분 | 컴파일러 | 인터프리터 |
|------|----------|------------|
| 변환 시점 | 실행 전 전체 변환 | 실행 중 한 줄씩 변환 |
| 실행 속도 | 빠름 | 느림 |
| 개발 속도 | 느림 (컴파일 필요) | 빠름 (즉시 실행) |
| 에러 발견 | 컴파일 시 | 런타임 시 |
| 산출물 | 실행 파일 | 없음 |
| 예시 | C, C++, Rust, Go | Python, JavaScript, Ruby |

### 하이브리드 방식 ◑

| 방식 | 설명 | 예시 |
|------|------|------|
| **바이트코드 컴파일** | 중간 코드로 컴파일 후 VM에서 실행 | Java (javac → JVM), Python (.pyc) |
| **JIT 컴파일** | 런타임에 기계어로 컴파일 | JVM HotSpot, V8, PyPy |
| **AOT 컴파일** | 설치/배포 시 미리 컴파일 | Android ART, GraalVM Native Image |

### JIT (Just-In-Time) 컴파일러 ◑

```
소스 코드 → 바이트코드 → [JIT] → 기계어
                         ↑
                    핫스팟 감지
                    (자주 실행되는 코드)
```

- 자주 실행되는 코드(핫스팟)만 컴파일
- 런타임 정보를 활용한 최적화 가능
- 초기 시작은 느리지만, 장기 실행 시 네이티브에 근접한 성능

### 컴파일러 내부 구조 ◑

```
소스 코드 → [프론트엔드] → IR → [백엔드] → 기계어

           ┌─────────────────────┐
           │     프론트엔드       │
           │  ┌───────────────┐  │
           │  │ 어휘 분석     │──│──→ 토큰
           │  │ (Lexer)       │  │
           │  └───────────────┘  │
           │  ┌───────────────┐  │
           │  │ 구문 분석     │──│──→ AST (추상 구문 트리)
           │  │ (Parser)      │  │
           │  └───────────────┘  │
           │  ┌───────────────┐  │
           │  │ 의미 분석     │──│──→ 타입 검사, 심볼 테이블
           │  │ (Semantic)    │  │
           │  └───────────────┘  │
           └─────────────────────┘
                     ↓
              IR (중간 표현)
                     ↓
           ┌─────────────────────┐
           │      백엔드         │
           │  ┌───────────────┐  │
           │  │ 최적화        │  │
           │  │ (Optimizer)   │  │
           │  └───────────────┘  │
           │  ┌───────────────┐  │
           │  │ 코드 생성     │  │
           │  │ (Code Gen)    │  │
           │  └───────────────┘  │
           └─────────────────────┘
```

### ⭕ 컴파일러의 각 단계 ◑

| 단계 | 역할 | 입력 | 출력 |
|------|------|------|------|
| **어휘 분석 (Lexer)** | 문자열을 토큰으로 분리 | 소스 코드 | 토큰 스트림 |
| **구문 분석 (Parser)** | 문법에 맞게 트리 구조로 변환 | 토큰 | AST (추상 구문 트리) |
| **의미 분석** | 타입 검사, 변수 바인딩, 스코프 | AST | 주석이 달린 AST |
| **중간 코드 생성** | 플랫폼 독립적 중간 표현 생성 | AST | IR (예: LLVM IR) |
| **최적화** | 성능 향상을 위한 변환 | IR | 최적화된 IR |
| **코드 생성** | 대상 플랫폼 기계어 생성 | IR | 어셈블리/기계어 |

### 예시: `int x = 1 + 2;` 컴파일 과정 ◑

```
1. 어휘 분석 (Lexing):
   "int x = 1 + 2;" → [INT, ID(x), ASSIGN, NUM(1), PLUS, NUM(2), SEMICOLON]

2. 구문 분석 (Parsing):
   토큰 → AST:
            VarDecl
           /   |   \
        int    x   BinaryExpr
                   /    |    \
                 NUM  PLUS  NUM
                 (1)        (2)

3. 의미 분석:
   - x의 타입이 int인지 확인
   - 1 + 2의 결과가 int인지 확인
   - x를 심볼 테이블에 등록

4. 코드 생성:
   mov eax, 1
   add eax, 2
   mov [x], eax
```

### 주요 컴파일러/인터프리터 구현 ◑

| 언어 | 컴파일러/인터프리터 | 특징 |
|------|-------------------|------|
| C/C++ | GCC, Clang (LLVM) | 네이티브 컴파일 |
| Rust | rustc (LLVM) | 안전성 검사 |
| Go | gc | 빠른 컴파일 |
| Java | javac + JVM | 바이트코드 + JIT |
| Python | CPython, PyPy | 인터프리터, PyPy는 JIT |
| JavaScript | V8, SpiderMonkey | JIT 컴파일러 |

---

## 5. 데이터 표현 ◑

### 문자 인코딩 ◑

| 인코딩 | 설명 | 크기 |
|--------|------|------|
| **ASCII** | 영문 128자 | 7비트 |
| **ISO-8859-1** | 서유럽 문자 | 8비트 |
| **EUC-KR** | 한국어 완성형 | 2바이트 |
| **UTF-8** | 유니코드, 가변 길이 | 1~4바이트 |
| **UTF-16** | 유니코드, 고정/가변 | 2~4바이트 |
| **UTF-32** | 유니코드, 고정 길이 | 4바이트 |

### ⭕ UTF-8과 UTF-16의 차이는?

| 구분 | UTF-8 | UTF-16 |
|------|-------|--------|
| 영문 | 1바이트 | 2바이트 |
| 한글 | 3바이트 | 2바이트 |
| 호환성 | ASCII 호환 | 비호환 |
| 사용처 | 웹, Unix | Windows 내부, Java |
| BOM | 선택적 | 권장 |

### 엔디안 (Endianness) ◑

멀티바이트 데이터를 메모리에 저장하는 순서이다.

| 방식 | 설명 | 예시 (0x12345678 저장) | 사용처 |
|------|------|----------------------|--------|
| **Big Endian** | MSB(최상위 바이트)가 낮은 주소에 | 12 34 56 78 | 네트워크 바이트 순서 |
| **Little Endian** | LSB(최하위 바이트)가 낮은 주소에 | 78 56 34 12 | x86, ARM, 대부분의 CPU |

### 부동소수점 (IEEE 754) ◑

```
32비트 (float):  1비트 부호 + 8비트 지수 + 23비트 가수
64비트 (double): 1비트 부호 + 11비트 지수 + 52비트 가수
```

**주의점:**
- 정밀도 손실: `0.1 + 0.2 != 0.3`
- 금융 계산에는 Decimal/BigDecimal 사용

---

## 6. 버전 관리와 의미적 버전 ◑

### 시맨틱 버저닝 (SemVer) ◑

```
MAJOR.MINOR.PATCH (예: 2.1.3)
```

| 구분 | 변경 시점 |
|------|----------|
| MAJOR | 호환되지 않는 API 변경 |
| MINOR | 하위 호환되는 기능 추가 |
| PATCH | 하위 호환되는 버그 수정 |

### 프리릴리즈와 메타데이터 ◑

```
1.0.0-alpha
1.0.0-beta.2
1.0.0-rc.1
1.0.0+build.123
```

---

## 7. 동시성 vs 병렬성 ◑

### ⭕ 동시성과 병렬성의 차이는?

| 구분 | 동시성 (Concurrency) | 병렬성 (Parallelism) |
|------|---------------------|---------------------|
| 정의 | 여러 작업을 번갈아 처리 | 여러 작업을 동시에 처리 |
| 실행 | 논리적 동시 실행 | 물리적 동시 실행 |
| 필요 조건 | 단일 코어로 가능 | 멀티 코어 필요 |
| 목적 | 응답성, I/O 효율 | 처리량 향상 |

```
동시성 (단일 코어):
Task A: ████    ████
Task B:     ████    ████

병렬성 (멀티 코어):
Core 1: ████████
Core 2: ████████
```

---

## 8. 에러 처리 패턴 ◑

### 예외 (Exception) vs 에러 코드 ◑

| 방식 | 장점 | 단점 | 언어 |
|------|------|------|------|
| **예외** | 명확한 에러 전파, 정상 로직 분리 | 성능 오버헤드, 숨겨진 제어 흐름 | Java, Python, C++ |
| **에러 코드** | 명시적, 가벼움 | 무시 가능, 코드 복잡 | C |
| **에러 값 반환** | 명시적, 타입 안전 | 매번 검사 필요 | Go (error 인터페이스) |
| **Result 타입** | 명시적, 처리 강제 | 패턴 매칭 필요 | Rust, Haskell |

### Checked vs Unchecked Exception ◑

| 구분 | Checked | Unchecked |
|------|---------|-----------|
| 처리 | 반드시 처리 또는 선언 | 선택적 |
| 예시 | IOException | NullPointerException |
| 사용 | 복구 가능한 오류 | 프로그래밍 오류 |

---

## 9. 직렬화 (Serialization) ◑

### ⭕ 직렬화란?

객체를 저장하거나 전송할 수 있는 형태로 변환하는 것이다.

| 형식 | 특징 | 용도 |
|------|------|------|
| **JSON** | 텍스트, 가독성 좋음 | REST API, 설정 |
| **XML** | 텍스트, 스키마 지원 | 설정, SOAP |
| **Protocol Buffers** | 바이너리, 고성능 | gRPC, 내부 통신 |
| **MessagePack** | 바이너리 JSON | 캐시, 빠른 직렬화 |
| **YAML** | 텍스트, 가독성 최고 | 설정 파일 |

### 깊은 복사 vs 얕은 복사 ◑

| 구분 | 얕은 복사 (Shallow Copy) | 깊은 복사 (Deep Copy) |
|------|-------------------------|---------------------|
| 동작 | 참조만 복사 | 객체 전체 재귀적 복사 |
| 원본 영향 | 중첩 객체 수정 시 영향 | 독립적 |
| 성능 | 빠름 | 느림 |

```python
original = {"name": "Kim", "scores": [90, 85]}

# 얕은 복사: scores 리스트는 같은 객체를 참조
shallow = original.copy()
shallow["scores"].append(95)
print(original["scores"])  # [90, 85, 95] ← 원본도 변경됨!

# 깊은 복사: 완전히 독립적인 새 객체
import copy
deep = copy.deepcopy(original)
deep["scores"].append(100)
print(original["scores"])  # [90, 85, 95] ← 원본 영향 없음
```

---

## 10. 빌드와 배포 ◑

### 빌드 산출물 ◑

| 산출물 | 설명 | 예시 |
|--------|------|------|
| 실행 파일 | 네이티브 바이너리 | .exe, ELF |
| 라이브러리 | 재사용 코드 | .dll, .so, .a |
| 패키지 | 배포 단위 | .jar, .whl, npm 패키지 |
| 컨테이너 이미지 | 실행 환경 포함 | Docker image |

### 정적 링킹 vs 동적 링킹 ◑

| 구분 | 정적 링킹 | 동적 링킹 |
|------|----------|----------|
| 시점 | 컴파일 타임 | 런타임 |
| 실행 파일 크기 | 큼 | 작음 |
| 의존성 | 없음 (독립적) | DLL/SO 필요 |
| 메모리 | 각 프로세스에 복사 | 공유 가능 |
| 업데이트 | 재컴파일 필요 | 라이브러리만 교체 |

---

## 11. 라이선스 기초 ◑

### 오픈소스 라이선스 ◑

| 라이선스 | 조건 | 사용 예시 |
|----------|------|----------|
| **MIT** | 거의 제한 없음, 저작권 표시 | Node.js, React |
| **Apache 2.0** | 특허권 포함, 변경 명시 | Android, Kafka |
| **GPL v3** | 파생물도 GPL, 소스 공개 | Linux Kernel |
| **LGPL** | 라이브러리 사용 시 소스 공개 불필요 | Qt (일부) |
| **BSD** | MIT와 유사 | FreeBSD |

### Copyleft vs Permissive ◑

| 유형 | 설명 | 라이선스 |
|------|------|----------|
| **Copyleft** | 파생물에도 동일 라이선스 적용 | GPL, AGPL |
| **Permissive** | 상업적 사용, 독점 소프트웨어에 포함 가능 | MIT, Apache, BSD |

---

## 면접 대비 체크리스트 ◑

- [ ] 프로그래밍 패러다임 (절차적, 객체지향, 함수형)
- [ ] 펌웨어, 미들웨어, 드라이버의 차이
- [ ] 라이브러리 vs 프레임워크 (IoC)
- [ ] SDK, API, 플랫폼의 개념
- [ ] 컴파일러 vs 인터프리터
- [ ] JIT 컴파일의 동작 원리
- [ ] UTF-8 vs UTF-16
- [ ] Big Endian vs Little Endian
- [ ] 동시성 vs 병렬성
- [ ] 직렬화 형식 (JSON, Protocol Buffers 등)
- [ ] 정적 링킹 vs 동적 링킹
- [ ] 시맨틱 버저닝 (SemVer)
- [ ] 주요 오픈소스 라이선스 특징
