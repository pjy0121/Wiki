# 03. 자료구조와 알고리즘 (Data Structures & Algorithms)

---

# Part A. 자료구조

## 시간 복잡도 요약

| 자료구조 | 접근 | 탐색 | 삽입 | 삭제 |
|----------|------|------|------|------|
| 배열 | O(1) | O(n) | O(n) | O(n) |
| 연결 리스트 | O(n) | O(n) | O(1) | O(1) |
| 스택 | O(n) | O(n) | O(1) | O(1) |
| 큐 | O(n) | O(n) | O(1) | O(1) |
| 해시 테이블 | - | O(1) | O(1) | O(1) |
| BST (평균) | - | O(log n) | O(log n) | O(log n) |
| 힙 | - | O(n) | O(log n) | O(log n) |

---

## 1. 선형 자료구조 ◑

### 배열 (Array) ◑

연속된 메모리 공간에 동일한 타입의 요소를 저장하는 자료구조이다.

| 특징 | 설명 |
|------|------|
| 메모리 | 연속된 메모리 블록 |
| 인덱스 접근 | O(1) - 인덱스로 즉시 접근 |
| 삽입/삭제 | O(n) - 요소 이동 필요 |
| 크기 | 정적 (선언 시 고정) |

### ⭕ 배열과 연결 리스트의 차이는?

| 구분 | 배열 | 연결 리스트 |
|------|------|-------------|
| 메모리 구조 | 연속적 | 비연속적 (포인터로 연결) |
| 접근 속도 | O(1) - 인덱스 접근 | O(n) - 순차 탐색 |
| 삽입/삭제 | O(n) - 요소 이동 | O(1) - 포인터만 변경 |
| 메모리 효율 | 높음 | 낮음 (포인터 추가 공간) |
| 크기 변경 | 어려움 | 용이 |
| 캐시 효율 | 좋음 (지역성) | 나쁨 |

### 연결 리스트 (Linked List) ◑

노드들이 포인터로 연결된 자료구조이다.

| 종류 | 설명 |
|------|------|
| 단일 연결 리스트 | 각 노드가 다음 노드만 가리킴 |
| 이중 연결 리스트 | 각 노드가 이전/다음 노드 모두 가리킴 |
| 원형 연결 리스트 | 마지막 노드가 첫 번째 노드를 가리킴 |

### 스택 (Stack) ◑

**LIFO** (Last In, First Out) 원칙을 따르는 자료구조이다.

| 연산 | 설명 | 시간 복잡도 |
|------|------|-------------|
| Push | 요소를 top에 추가 | O(1) |
| Pop | top 요소 제거 및 반환 | O(1) |
| Peek/Top | top 요소 조회 | O(1) |

**활용**: 함수 호출 스택, Undo/Redo, 괄호 매칭, DFS

### 큐 (Queue) ◑

**FIFO** (First In, First Out) 원칙을 따르는 자료구조이다.

| 종류 | 설명 |
|------|------|
| 원형 큐 | rear와 front가 연결되어 공간 효율적 |
| 우선순위 큐 | 우선순위에 따라 요소 처리 |
| 덱 (Deque) | 양쪽 끝에서 삽입/삭제 가능 |

**활용**: BFS, 작업 스케줄링, 버퍼 관리

### ⭕ 스택과 큐의 차이는?

| 구분 | 스택 | 큐 |
|------|------|------|
| 원칙 | LIFO (후입선출) | FIFO (선입선출) |
| 대표 활용 | DFS, 함수 호출 | BFS, 작업 스케줄링 |

---

## 2. 트리 (Tree) ◑

계층적 구조를 표현하는 비선형 자료구조이다.

### 트리 순회 (Tree Traversal) ◑

| 순회 방식 | 순서 | 활용 |
|----------|------|------|
| 전위 (Preorder) | 루트 → 왼쪽 → 오른쪽 | 트리 복사 |
| 중위 (Inorder) | 왼쪽 → 루트 → 오른쪽 | BST에서 정렬된 출력 |
| 후위 (Postorder) | 왼쪽 → 오른쪽 → 루트 | 트리 삭제 |
| 레벨 (Level Order) | 레벨별 왼쪽→오른쪽 | BFS |

### 이진 탐색 트리 (BST) ◑

왼쪽 서브트리 < 루트 < 오른쪽 서브트리

| 연산 | 평균 | 최악 (편향) |
|------|------|-------------|
| 탐색/삽입/삭제 | O(log n) | O(n) |

### ⭕ BST와 힙의 차이는?

| 구분 | BST | 힙 |
|------|-----|-----|
| 정렬 기준 | 왼쪽 < 루트 < 오른쪽 | 부모 ≥ 자식 (최대힙) |
| 구조 | 이진 트리 | 완전 이진 트리 |
| 저장 방식 | 포인터 기반 | 배열 기반 |
| 최댓값/최솟값 접근 | O(log n) | O(1) |
| 용도 | 정렬된 데이터 관리 | 우선순위 큐, 힙 정렬 |

### 힙 (Heap) ◑

완전 이진 트리 기반, 부모-자식 간 대소 관계 유지

**배열 인덱스 관계** (0-indexed): 부모 `(i-1)/2`, 왼쪽 자식 `2i+1`, 오른쪽 자식 `2i+2`

### 자가 균형 트리 ◑

| 트리 | 특징 |
|------|------|
| AVL 트리 | 높이 차이 1 이하, 엄격한 균형 |
| 레드-블랙 트리 | 색상 규칙으로 균형 유지 |
| B-트리 | 다진 트리, DB 인덱스에 사용 |

---

## 3. 그래프 (Graph) ◑

정점(Vertex)과 간선(Edge)으로 구성된 자료구조이다.

### 그래프 표현 방법 ◑

| 방법 | 공간 | 간선 확인 | 적합한 경우 |
|------|------|-----------|-------------|
| 인접 행렬 | O(V²) | O(1) | 밀집 그래프 |
| 인접 리스트 | O(V + E) | O(V) | 희소 그래프 |

### ⭕ 트리와 그래프의 차이는?

| 구분 | 트리 | 그래프 |
|------|------|--------|
| 사이클 | 없음 | 있을 수 있음 |
| 루트 | 있음 | 없음 |
| 간선 수 | n-1 | 제한 없음 |

---

## 4. 해시 (Hash) ◑

키를 해시 함수로 변환하여 값을 저장하는 자료구조이다.

### ⭕ 해시 충돌이란? 해결 방법은?

서로 다른 키가 동일한 해시값을 가지는 현상이다.

| 방법 | 설명 |
|------|------|
| 체이닝 | 같은 인덱스에 연결 리스트로 저장 |
| 개방 주소법 | 충돌 시 다른 빈 슬롯 탐색 (선형/이차/이중 해싱) |

---

## 5. 기타 자료구조 ◑

| 자료구조 | 특징 | 활용 |
|----------|------|------|
| 트라이 (Trie) | O(m) 문자열 검색 | 자동완성, 사전 |
| 유니온-파인드 | O(α(n)) 집합 관리 | MST, 사이클 탐지 |

---

# Part B. 알고리즘

## 6. 복잡도 분석 ◑

### Big-O 표기법

```
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)
```

| 복잡도 | 명칭 | 예시 |
|--------|------|------|
| O(1) | 상수 | 배열 인덱스 접근 |
| O(log n) | 로그 | 이진 탐색 |
| O(n) | 선형 | 선형 탐색 |
| O(n log n) | 선형 로그 | 병합 정렬 |
| O(n²) | 이차 | 버블 정렬 |

### 계산 복잡도 이론 ◑

#### ⭕ P, NP, NP-Complete, NP-Hard란?

| 분류 | 정의 | 예시 |
|------|------|------|
| **P** | 다항 시간에 **해결** 가능 | 정렬, 최단 경로, MST |
| **NP** | 다항 시간에 **검증** 가능 | 해밀턴 경로, SAT |
| **NP-Complete** | NP이면서 모든 NP 문제가 환원 가능 | SAT, 3-SAT, TSP(결정), 정점 커버 |
| **NP-Hard** | 모든 NP 문제가 환원 가능 (NP에 속할 필요 없음) | TSP(최적화), 정지 문제 |

```
    ┌─────────────────────────────────────────────┐
    │                   NP-Hard                   │
    │                                             │
    │    ┌─────────────────────────────────┐      │
    │    │              NP                 │      │
    │    │                                 │      │
    │    │   ┌─────────┐   ┌───────────┐   │      │
    │    │   │    P    │   │NP-Complete│   │      │
    │    │   └─────────┘   └───────────┘   │      │
    │    │                                 │      │
    │    └─────────────────────────────────┘      │
    │                                             │
    └─────────────────────────────────────────────┘
                    (P ≠ NP 가정 시)
```

> **핵심:** P ≠ NP 가정 시, P와 NP-Complete는 서로 겹치지 않는다. 만약 P = NP라면 P = NP = NP-Complete가 된다.

#### ⭕ P = NP 문제란? ◑

"다항 시간에 검증 가능한 문제가 다항 시간에 해결 가능한가?"라는 미해결 문제이다.
- **P = NP**: 모든 NP 문제가 효율적으로 풀림 (암호 체계 붕괴)
- **P ≠ NP**: NP-Complete 문제는 효율적 알고리즘 없음 (대부분 학자 예상)

#### 다항 시간 환원 (Reduction) ◑

문제 A를 문제 B로 다항 시간에 변환할 수 있으면, B가 A 이상으로 어렵다.

```
A ≤p B: A를 다항 시간에 B로 환원 가능
→ B를 풀 수 있으면 A도 풀 수 있다
→ B가 A보다 최소한 같거나 어렵다
```

#### 대표적인 NP-Complete 문제 ◑

| 문제 | 설명 |
|------|------|
| **SAT** | 부울 식을 참으로 만드는 변수 할당 (최초의 NP-Complete) |
| **3-SAT** | 절(clause)당 3개 리터럴인 SAT |
| **TSP (결정)** | 주어진 비용 이하로 모든 도시 순회 가능? |
| **해밀턴 경로** | 모든 정점을 한 번씩 방문하는 경로 존재? |
| **정점 커버** | k개 정점으로 모든 간선 커버 가능? |
| **부분집합 합** | 부분집합의 합이 목표값이 되는가? |
| **그래프 색칠** | k개 색으로 인접 정점을 다른 색으로 칠할 수 있는가? |

#### NP-Complete 문제 대응 전략 ◑

| 전략 | 설명 |
|------|------|
| **근사 알고리즘** | 최적해에 가까운 해를 다항 시간에 찾음 |
| **휴리스틱** | 경험적 규칙으로 좋은 해 탐색 |
| **특수 케이스** | 입력 제한 시 다항 시간 가능 |
| **지수 시간 알고리즘** | 작은 입력에서 정확한 해 |
| **파라미터화 복잡도** | 특정 파라미터 고정 시 효율적 |

---

## 7. 정렬 알고리즘 ◑

### 정렬 알고리즘 비교

| 알고리즘 | 평균 | 최악 | 공간 | 안정성 |
|----------|------|------|------|--------|
| 버블 정렬 | O(n²) | O(n²) | O(1) | 안정 |
| 선택 정렬 | O(n²) | O(n²) | O(1) | 불안정 |
| 삽입 정렬 | O(n²) | O(n²) | O(1) | 안정 |
| 병합 정렬 | O(n log n) | O(n log n) | O(n) | 안정 |
| 퀵 정렬 | O(n log n) | O(n²) | O(log n) | 불안정 |
| 힙 정렬 | O(n log n) | O(n log n) | O(1) | 불안정 |

### ⭕ 퀵 정렬과 병합 정렬의 차이는?

| 구분 | 퀵 정렬 | 병합 정렬 |
|------|---------|-----------|
| 분할 방식 | 피벗 기준 분할 | 단순 반분할 |
| 시간 복잡도 | 평균 O(n log n), 최악 O(n²) | 항상 O(n log n) |
| 공간 복잡도 | O(log n) | O(n) |
| 안정성 | 불안정 | 안정 |
| 실제 성능 | 일반적으로 더 빠름 | 일관된 성능 |

### 비교 기반이 아닌 정렬 ◑

| 알고리즘 | 시간 복잡도 | 특징 |
|----------|-------------|------|
| Counting Sort | O(n + k) | 정수, 범위 k가 작을 때 |
| Radix Sort | O(d × (n + k)) | 자릿수 d개, 고정 길이 키 |
| Bucket Sort | O(n + k) | 균등 분포 데이터 |

**비교 정렬 하한**: 비교 기반 정렬은 Ω(n log n)이 하한이지만, 위 알고리즘들은 특정 조건에서 O(n) 달성

---

## 8. 탐색 알고리즘 ◑

### 이진 탐색 (Binary Search) ◑

**정렬된 배열**에서 중간값과 비교하여 탐색 범위를 절반씩 줄인다. O(log n)

### ⭕ BFS와 DFS의 차이는?

| 구분 | BFS | DFS |
|------|-----|-----|
| 탐색 순서 | 너비 우선 (레벨 순) | 깊이 우선 |
| 자료구조 | 큐 | 스택/재귀 |
| 최단 경로 | 보장 (가중치 없을 때) | 보장 안 됨 |
| 적합한 경우 | 최단 경로, 레벨 탐색 | 모든 경로, 백트래킹 |

---

## 9. 동적 프로그래밍 (DP) ◑

큰 문제를 작은 부분 문제로 나누어 해결하고, 결과를 저장하여 재사용한다.

### DP 적용 조건 ◑

- **최적 부분 구조**: 큰 문제의 최적해가 부분 문제의 최적해로 구성
- **중복 부분 문제**: 동일한 부분 문제가 반복

### ⭕ 메모이제이션과 타뷸레이션의 차이는?

| 구분 | 메모이제이션 (Top-Down) | 타뷸레이션 (Bottom-Up) |
|------|------------------------|----------------------|
| 방식 | 재귀 + 캐싱 | 반복문 + 테이블 |
| 계산 순서 | 필요한 부분만 | 모든 부분 문제 |
| 스택 오버플로우 | 가능성 있음 | 없음 |

```python
# 피보나치 예시

# 메모이제이션 (Top-Down): fib(5)를 호출하면 필요한 것만 계산
def fib_memo(n, cache={}):
    if n <= 1: return n
    if n not in cache:
        cache[n] = fib_memo(n-1) + fib_memo(n-2)
    return cache[n]

# 타뷸레이션 (Bottom-Up): fib(0)부터 순서대로 모두 계산
def fib_tab(n):
    dp = [0, 1]
    for i in range(2, n+1):
        dp.append(dp[i-1] + dp[i-2])
    return dp[n]
```

### 대표적인 DP 문제 ◑

피보나치, 0/1 배낭, LCS, LIS, 편집 거리, 동전 교환

---

## 10. 그리디 알고리즘 ◑

매 순간 **최선의 선택**을 하여 전체 최적해를 구한다.

### ⭕ 그리디와 DP의 차이는?

| 구분 | 그리디 | DP |
|------|--------|-----|
| 선택 방식 | 현재 최선 선택 | 모든 경우 고려 |
| 되돌아감 | 없음 | 가능 |
| 최적해 보장 | 조건 충족 시에만 | 항상 |

```
예시: 동전 12원을 만드는 최소 동전 개수

동전: [1, 5, 10]
- 그리디: 10 + 1 + 1 = 3개 ✓ (최적)
- DP: 10 + 1 + 1 = 3개 ✓ (최적)

동전: [1, 3, 4]
- 그리디: 4 + 4 + 4 = 3개 (12 = 4×3)
- DP: 3 + 3 + 3 + 3 = 4개? → 아니, 4 + 4 + 3 + 1? → 4 + 4 + 4 = 3개!
  실제로는 같지만...

동전: [1, 3, 4]로 6원을 만들면?
- 그리디: 4 + 1 + 1 = 3개
- DP: 3 + 3 = 2개 ✓ (최적)
→ 그리디는 실패할 수 있음!
```

---

## 11. 그래프 알고리즘 ◑

### 최단 경로 알고리즘 ◑

| 알고리즘 | 특징 | 시간 복잡도 |
|----------|------|-------------|
| 다익스트라 | 단일 출발점, 음수 불가 | O(E log V) |
| 벨만-포드 | 음수 가능 | O(VE) |
| 플로이드-워셜 | 모든 쌍 | O(V³) |

### ⭕ 다익스트라 알고리즘의 원리는?

우선순위 큐로 최단 거리 정점부터 방문하며 거리 갱신. **음수 가중치 불가**.

### 최소 신장 트리 (MST) ◑

| 알고리즘 | 방식 | 시간 복잡도 |
|----------|------|-------------|
| 크루스칼 | 간선 정렬 + Union-Find | O(E log E) |
| 프림 | 정점 기준 확장 | O(E log V) |

### ⭕ 위상 정렬 (Topological Sort)이란? ◑

DAG(방향 비순환 그래프)에서 모든 간선 (u, v)에 대해 u가 v보다 앞에 오도록 정점을 정렬하는 것이다.

| 알고리즘 | 방식 | 특징 |
|----------|------|------|
| **DFS 기반** | 후위 순회 역순 | 스택에 완료 순서 저장 |
| **Kahn's (BFS)** | 진입 차수 0인 정점부터 제거 | 사이클 탐지 용이 |

**시간 복잡도**: O(V + E)

**활용**: 작업 스케줄링, 빌드 시스템, 선수 과목 결정

---

## 12. 백트래킹과 분할 정복 ◑

### 백트래킹 ◑

가능한 모든 경우를 탐색하되, 조건에 맞지 않으면 **가지치기(pruning)**

**대표 문제**: N-Queens, 순열/조합, 스도쿠

### 분할 정복 ◑

문제를 작은 부분으로 나누어 해결 후 결합

**대표 알고리즘**: 병합 정렬, 퀵 정렬, 이진 탐색

---

## 13. 문자열 알고리즘 ◑

### 문자열 탐색 알고리즘 ◑

텍스트에서 패턴을 찾는 알고리즘이다.

| 알고리즘 | 시간 복잡도 | 특징 |
|----------|-------------|------|
| **Brute Force** | O(nm) | 단순 비교, 구현 쉬움 |
| **KMP** | O(n + m) | 실패 함수로 불필요한 비교 회피 |
| **Rabin-Karp** | O(n + m) 평균 | 해시 기반, 다중 패턴 검색에 유리 |
| **Boyer-Moore** | O(n/m) 최선 | 뒤에서 앞으로 비교, 실무에서 가장 빠름 |

(n: 텍스트 길이, m: 패턴 길이)

### ⭕ KMP 알고리즘의 원리는? ◑

패턴의 접두사와 접미사가 일치하는 정보(실패 함수)를 미리 계산하여, 불일치 시 처음부터 다시 비교하지 않고 일치했던 부분을 활용한다.

```
패턴: ABABC
실패 함수: [0, 0, 1, 2, 0]
→ AB가 접두사이자 접미사로 반복됨을 활용
```

### 문자열 자료구조 ◑

| 자료구조 | 특징 | 활용 |
|----------|------|------|
| **Trie** | 문자 단위 트리, O(m) 탐색 | 자동완성, 사전 |
| **Suffix Array** | 접미사 정렬 배열, O(n log n) 구축 | 문자열 검색, LCP |
| **Suffix Tree** | 모든 접미사를 트리로, O(n) 구축 | 패턴 매칭, 최장 반복 부분 문자열 |

### 대표적인 문자열 문제 ◑

| 문제 | 알고리즘 | 시간 복잡도 |
|------|----------|-------------|
| 최장 공통 부분 수열 (LCS) | DP | O(nm) |
| 최장 공통 접두사 (LCP) | Suffix Array + DP | O(n) |
| 최장 반복 부분 문자열 | Suffix Array/Tree | O(n log n) |
| 편집 거리 | DP | O(nm) |
| 회문 판별 | 투 포인터 / Manacher | O(n) |

---

## 14. 고급 자료구조 ◑

### 세그먼트 트리 (Segment Tree) ◑

구간 쿼리와 업데이트를 효율적으로 처리하는 트리 자료구조이다.

| 연산 | 시간 복잡도 |
|------|-------------|
| 구간 쿼리 (합, 최소, 최대 등) | O(log n) |
| 점 업데이트 | O(log n) |
| 구간 업데이트 (Lazy Propagation) | O(log n) |
| 공간 복잡도 | O(n) |

**활용**: 구간 합, 구간 최솟값/최댓값, 구간 GCD

```
        [0,7]
       /     \
    [0,3]    [4,7]
    /   \    /   \
 [0,1] [2,3] [4,5] [6,7]
```

### 펜윅 트리 (Fenwick Tree / BIT) ◑

Binary Indexed Tree. 세그먼트 트리보다 구현이 간단하고 메모리 효율적이다.

| 연산 | 시간 복잡도 |
|------|-------------|
| 구간 합 쿼리 | O(log n) |
| 점 업데이트 | O(log n) |
| 공간 복잡도 | O(n) |

**특징**: 구간 합에 특화, 최솟값/최댓값은 지원하지 않음

### 희소 테이블 (Sparse Table) ◑

정적 배열에서 구간 쿼리를 O(1)에 처리한다.

| 연산 | 시간 복잡도 |
|------|-------------|
| 전처리 | O(n log n) |
| 쿼리 (최솟값, 최댓값, GCD) | O(1) |
| 공간 복잡도 | O(n log n) |

**제한**: 업데이트 불가, 덮어쓰기 연산만 가능 (합은 불가)

---

## 15. 고급 알고리즘 ◑

### 투 포인터 (Two Pointers) ◑

두 개의 포인터를 사용하여 선형 시간에 문제를 해결한다.

| 유형 | 설명 | 예시 |
|------|------|------|
| **같은 방향** | 두 포인터가 같은 방향으로 이동 | 연속 부분 배열 합 |
| **반대 방향** | 양 끝에서 시작하여 중앙으로 | 정렬된 배열에서 두 수의 합 |

### 슬라이딩 윈도우 (Sliding Window) ◑

고정 또는 가변 크기의 윈도우를 이동하며 부분 배열을 처리한다.

**활용**: 최대/최소 부분 배열 합, 문자열 패턴, 연속 k개 원소의 합

### 네트워크 플로우 (Network Flow) ◑

| 알고리즘 | 시간 복잡도 | 특징 |
|----------|-------------|------|
| **Ford-Fulkerson** | O(E × max_flow) | DFS 기반, 정수 용량 시 |
| **Edmonds-Karp** | O(VE²) | BFS 기반 Ford-Fulkerson |
| **Dinic** | O(V²E) | 레벨 그래프 사용, 실제로 빠름 |

**핵심 개념:**
- **최대 유량 = 최소 컷** (Max-Flow Min-Cut Theorem)
- **잔여 그래프** (Residual Graph): 추가 유량 가능한 간선들
- **증가 경로** (Augmenting Path): 추가 유량을 보낼 수 있는 경로

**활용**: 이분 매칭, 작업 할당, 최소 비용 최대 유량

### 이분 매칭 (Bipartite Matching) ◑

이분 그래프에서 최대 매칭을 찾는다.

| 알고리즘 | 시간 복잡도 |
|----------|-------------|
| **Hungarian** | O(V³) |
| **Hopcroft-Karp** | O(E√V) |
| **네트워크 플로우 환원** | O(VE) |

### A* 알고리즘 ◑

휴리스틱을 사용한 최단 경로 탐색 알고리즘이다.

```
f(n) = g(n) + h(n)
```

| 구성 요소 | 설명 |
|-----------|------|
| **g(n)** | 시작점에서 현재 노드까지 실제 비용 |
| **h(n)** | 현재 노드에서 목표까지 추정 비용 (휴리스틱) |
| **f(n)** | 총 추정 비용 |

**휴리스틱 조건:**
- **Admissible**: 실제 비용을 과대평가하지 않음 → 최적해 보장
- **Consistent**: h(n) ≤ cost(n, n') + h(n')

**활용**: 게임 AI, 지도 경로 탐색, 퍼즐 풀이

### 최소 공통 조상 (LCA) ◑

트리에서 두 노드의 가장 가까운 공통 조상을 찾는다.

| 알고리즘 | 전처리 | 쿼리 |
|----------|--------|------|
| **단순 탐색** | O(1) | O(n) |
| **Binary Lifting** | O(n log n) | O(log n) |
| **Sparse Table + Euler Tour** | O(n log n) | O(1) |

### SCC (Strongly Connected Components) ◑

방향 그래프에서 강하게 연결된 정점들의 집합을 찾는다.

| 알고리즘 | 시간 복잡도 |
|----------|-------------|
| **Kosaraju** | O(V + E) |
| **Tarjan** | O(V + E) |

**활용**: 2-SAT, 그래프 축약

---

## 면접 대비 체크리스트 ◑

**자료구조**
- [ ] 배열 vs 연결 리스트 차이
- [ ] 스택/큐 활용 사례
- [ ] BST vs 힙 차이
- [ ] 해시 충돌 해결 방법
- [ ] 그래프 표현 방법

**알고리즘**
- [ ] Big-O 표기법과 예시
- [ ] P, NP, NP-Complete, NP-Hard 정의
- [ ] 퀵 정렬 vs 병합 정렬
- [ ] 비교 정렬 하한과 비교 기반 아닌 정렬
- [ ] BFS vs DFS 차이
- [ ] DP의 두 가지 접근 방식
- [ ] 그리디 vs DP 차이
- [ ] 다익스트라 알고리즘
- [ ] 위상 정렬 (DFS, Kahn's)
- [ ] 문자열 탐색 알고리즘 (KMP, Rabin-Karp)
- [ ] 세그먼트 트리와 펜윅 트리
- [ ] 네트워크 플로우 (Max-Flow Min-Cut)
- [ ] A* 알고리즘

