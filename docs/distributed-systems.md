# 13. 분산 시스템 (Distributed Systems)

---

## 1. 분산 시스템 기초 ◑

여러 컴퓨터가 네트워크로 연결되어 하나의 시스템처럼 동작하는 시스템이다.

### 분산 시스템의 특징 ◑

| 특징 | 설명 |
|------|------|
| 확장성 | 노드 추가로 성능 향상 가능 |
| 장애 허용 | 일부 노드 장애에도 시스템 동작 |
| 투명성 | 사용자에게 단일 시스템처럼 보임 |
| 복잡성 | 동기화, 일관성 관리 어려움 |

### 수평 확장 vs 수직 확장

| 구분 | 수평 확장 (Scale Out) | 수직 확장 (Scale Up) |
|------|----------------------|---------------------|
| 방법 | 서버 추가 | 서버 성능 향상 |
| 비용 | 선형적 | 지수적 |
| 한계 | 거의 무한 | 물리적 한계 |
| 복잡도 | 높음 (분산 처리) | 낮음 |
| 예시 | 로드 밸런서 + 다중 서버 | CPU, RAM 업그레이드 |

---

## 2. CAP 정리 ◑

분산 시스템은 다음 세 가지를 동시에 만족할 수 없음 (Eric Brewer, 2000)

| 속성 | 설명 |
|------|------|
| **C**onsistency | 모든 노드가 동일한 데이터를 가짐 |
| **A**vailability | 모든 요청에 응답 |
| **P**artition Tolerance | 네트워크 분할에도 동작 |

### ⭕ CAP 정리란? 왜 세 가지를 동시에 만족할 수 없는가?

네트워크 분할(Partition)은 분산 시스템에서 **불가피**하므로, 실제로는 **CP vs AP** 중 선택해야 한다.

| 유형 | 설명 | 예시 |
|------|------|------|
| **CP** | 일관성 우선, 가용성 포기 | HBase, MongoDB, Zookeeper |
| **AP** | 가용성 우선, 일관성 포기 | Cassandra, DynamoDB, CouchDB |

**네트워크 분할 발생 시:**
- CP: 응답하지 않더라도 정확한 데이터 보장
- AP: 오래된 데이터라도 응답 (Eventually Consistent)

### PACELC 정리 ◑

CAP 정리를 확장한 모델이다. 네트워크 **분할(Partition)이 없을 때** 추가 트레이드오프를 고려한다.

```
Partition 발생 시: A vs C 선택
Else (정상): Latency vs Consistency 선택
```

---

## 3. 일관성 모델 ◑

### ⭕ 강한 일관성과 최종 일관성의 차이는?

| 모델 | 설명 | 특징 |
|------|------|------|
| **강한 일관성 (Strong)** | 쓰기 직후 모든 읽기가 최신 데이터 반환 | 느림, 정확함 |
| **최종 일관성 (Eventual)** | 시간이 지나면 모든 노드가 일관된 상태 | 빠름, 일시적 불일치 |
| **인과 일관성 (Causal)** | 인과 관계 있는 연산 순서 보장 | 중간 수준 |

### 쿼럼 기반 일관성 ◑

| 변수 | 설명 |
|------|------|
| N | 총 복제본 수 |
| W | 쓰기 성공에 필요한 복제본 수 |
| R | 읽기 성공에 필요한 복제본 수 |

**강한 일관성 조건**: `W + R > N`

---

## 4. 합의 알고리즘 ◑

분산 노드들이 **하나의 값에 동의**하기 위한 알고리즘이다.

### ⭕ Raft 알고리즘이란?

Paxos를 이해하기 쉽게 재설계한 합의 알고리즘이다 (2013, Diego Ongaro).

**핵심 개념**

| 개념 | 설명 |
|------|------|
| Leader Election | 리더를 선출하여 모든 쓰기 처리 |
| Log Replication | 리더가 팔로워에게 로그 복제 |
| Safety | 커밋된 로그는 영구 보존 |

**동작 방식**
1. 리더가 클라이언트 요청을 받음
2. 로그 엔트리를 팔로워들에게 복제
3. 과반수 확인 후 커밋
4. 리더 장애 시 새 리더 선출 (임기 기반)

**사용 예시**: etcd, Consul, CockroachDB

### Paxos vs Raft ◑

| 구분 | Paxos | Raft |
|------|-------|------|
| 복잡도 | 높음 | 낮음 (이해하기 쉬움) |
| 리더 | 필수 아님 | 필수 |
| 리더 선출 | 복잡 | 단순 (최신 로그 우선) |
| 실사용 | Chubby, Spanner | etcd, Consul |

---

## 5. 데이터 분산 ◑

### 샤딩 (Sharding) ◑

데이터를 여러 노드에 분산 저장하는 기법이다.

| 방식 | 설명 | 장단점 |
|------|------|--------|
| 해시 샤딩 | 키의 해시값으로 샤드 결정 | 균등 분산, 범위 쿼리 어려움 |
| 범위 샤딩 | 키 범위별로 샤드 결정 | 범위 쿼리 용이, 핫스팟 위험 |
| 지리 샤딩 | 지역별로 샤드 결정 | 지역성 활용, 글로벌 쿼리 어려움 |

### Consistent Hashing ◑

노드 추가/삭제 시 **최소한의 데이터만 재분배**하는 해싱 기법이다.

| 특징 | 설명 |
|------|------|
| 원리 | 노드와 키를 동일한 해시 링에 배치 |
| 장점 | 노드 변경 시 영향 최소화 |
| 가상 노드 | 부하 균형을 위해 한 노드를 여러 포인트로 배치 |

### 복제 (Replication) ◑

동일한 데이터를 여러 노드에 복사하여 저장한다.

| 방식 | 설명 |
|------|------|
| 동기 복제 | 모든 복제본 완료 후 응답 (느림, 일관성) |
| 비동기 복제 | 일부 복제 후 응답 (빠름, 일관성 위험) |

**복제 토폴로지**
- 단일 리더: 하나의 리더만 쓰기 처리
- 다중 리더: 여러 리더가 쓰기 처리 (충돌 해결 필요)
- 리더 없음: 모든 노드가 쓰기 처리 (쿼럼 기반)

---

## 6. 메시지 큐 ◑

비동기 통신을 위한 중간 저장소로, 생산자와 소비자를 분리한다.

### ⭕ 메시지 큐를 사용하는 이유는?

| 이점 | 설명 |
|------|------|
| 비동기 처리 | 작업을 즉시 응답하고 나중에 처리 |
| 부하 분산 | 트래픽 피크 시 버퍼 역할 |
| 느슨한 결합 | 생산자/소비자 독립적 운영 |
| 장애 허용 | 일시적 장애에도 메시지 유실 방지 |

### 메시지 전달 보장 ◑

| 보장 수준 | 설명 |
|-----------|------|
| At-most-once | 최대 1회 (유실 가능) |
| At-least-once | 최소 1회 (중복 가능) |
| Exactly-once | 정확히 1회 (구현 어려움) |

### 대표적인 메시지 큐 ◑

| 시스템 | 특징 |
|--------|------|
| Kafka | 높은 처리량, 로그 기반, 순서 보장 |
| RabbitMQ | AMQP 프로토콜, 유연한 라우팅 |
| Amazon SQS | 관리형 서비스, 확장 용이 |
| Redis | 인메모리, 빠름, 간단한 큐 |

---

## 7. 로드 밸런싱 ◑

요청을 여러 서버에 분산하여 부하를 균등하게 분배한다.

### 로드 밸런싱 알고리즘 ◑

| 알고리즘 | 설명 |
|----------|------|
| 라운드 로빈 | 순서대로 분배 |
| 가중 라운드 로빈 | 서버 성능에 따라 가중치 적용 |
| 최소 연결 | 연결 수가 가장 적은 서버로 분배 |
| IP 해시 | 클라이언트 IP로 서버 결정 (세션 유지) |

### L4 vs L7 로드 밸런싱 ◑

| 구분 | L4 | L7 |
|------|-----|-----|
| 계층 | 전송 계층 | 응용 계층 |
| 기준 | IP, 포트 | URL, 헤더, 쿠키 |
| 속도 | 빠름 | 느림 (분석 필요) |
| 유연성 | 낮음 | 높음 |

---

## 8. 분산 시스템 패턴 ◑

### Circuit Breaker ◑

연속 실패 시 일시적으로 요청을 차단하여 장애 확산을 방지한다.

| 상태 | 설명 |
|------|------|
| Closed | 정상 동작, 실패 카운트 |
| Open | 요청 차단, 빠른 실패 반환 |
| Half-Open | 일부 요청 허용하여 복구 확인 |

### Saga 패턴 ◑

분산 트랜잭션을 일련의 로컬 트랜잭션으로 분리하고, 실패 시 보상 트랜잭션을 실행한다.

| 방식 | 설명 |
|------|------|
| Choreography | 이벤트 기반, 서비스 간 직접 통신 |
| Orchestration | 중앙 조정자가 트랜잭션 관리 |

### 2PC (Two-Phase Commit) ◑

분산 트랜잭션의 원자성을 보장하는 프로토콜이다.

| 단계 | 설명 |
|------|------|
| Prepare | 모든 참여자에게 준비 요청 |
| Commit/Abort | 모두 준비되면 커밋, 아니면 롤백 |

**단점**: 코디네이터 장애 시 블로킹

---

## 9. 분산 캐시 ◑

### 캐시 전략 ◑

| 전략 | 설명 |
|------|------|
| Cache-Aside | 애플리케이션이 캐시 관리 |
| Read-Through | 캐시 미스 시 캐시가 DB 조회 |
| Write-Through | 쓰기 시 캐시와 DB 동시 갱신 |
| Write-Behind | 쓰기 시 캐시만 갱신, 나중에 DB 반영 |

### 캐시 무효화 ◑

| 전략 | 설명 |
|------|------|
| TTL | 만료 시간 기반 |
| 이벤트 기반 | 데이터 변경 시 무효화 |
| 버전 기반 | 버전 번호로 유효성 확인 |

---

## 10. 시스템 설계 면접 사례 ◑

### 대표적인 설계 문제 ◑

| 문제 | 핵심 고려사항 |
|------|--------------|
| URL 단축기 | 해시 생성, 충돌 처리, 리다이렉션 캐싱 |
| 채팅 시스템 | WebSocket, 메시지 큐, 읽음 상태 동기화 |
| 뉴스피드 | Push vs Pull, 팬아웃, 타임라인 정렬 |
| Rate Limiter | Token Bucket, 분산 환경에서의 동기화 |
| 검색 자동완성 | Trie, 분산 캐시, 순위 알고리즘 |

### 설계 접근 단계 ◑

1. **요구사항 명확화**: 기능적/비기능적 요구사항 파악
2. **규모 추정**: QPS, 저장 용량, 대역폭 계산
3. **고수준 설계**: 주요 컴포넌트와 데이터 흐름
4. **상세 설계**: 데이터 모델, API, 핵심 알고리즘
5. **병목 식별**: 확장성, 장애 대응 방안

---

## 면접 대비 체크리스트 ◑

- [ ] CAP 정리와 CP/AP 시스템 예시
- [ ] 강한 일관성 vs 최종 일관성
- [ ] Raft 합의 알고리즘의 동작 원리
- [ ] 샤딩과 Consistent Hashing
- [ ] 메시지 큐의 역할과 전달 보장 수준
- [ ] 로드 밸런싱 알고리즘
- [ ] Circuit Breaker 패턴

