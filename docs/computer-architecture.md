# 01. 컴퓨터 구조 (Computer Architecture)

---

## 1. 컴퓨터 구조 기본 개념

### 폰 노이만 구조

- CPU, 메모리, 입출력 장치로 구성
- 프로그램과 데이터가 같은 메모리에 저장
- 명령어를 순차적으로 fetch → decode → execute

### 메모리 계층 구조

| 계층 | 속도 | 용량 | 비용 |
|------|------|------|------|
| 레지스터 | 가장 빠름 | 가장 작음 | 가장 비쌈 |
| 캐시 (L1/L2/L3) | 빠름 | 작음 | 비쌈 |
| 메인 메모리 (RAM) | 보통 | 보통 | 보통 |
| 보조 저장장치 (SSD/HDD) | 느림 | 큼 | 저렴 |

---

## 2. 캐시 (Cache) ◑

### ⭕ 캐시 매핑 방식을 설명하라

| 방식 | 설명 | 장점 | 단점 |
|------|------|------|------|
| **Direct Mapped** | 메모리 블록이 특정 캐시 라인에만 매핑 | 구현 간단, 접근 빠름 | 충돌 미스 많음 |
| **Fully Associative** | 어떤 캐시 라인에든 매핑 가능 | 충돌 미스 최소 | 비교기 많이 필요, 느림 |
| **Set Associative** | 특정 세트 내에서 자유롭게 매핑 (N-way) | 위 둘의 절충 | 적당한 복잡도 |

**주소 구성:**
```
| Tag | Index (Set) | Offset |
```
- Direct Mapped: 1-way set associative
- Fully Associative: 1개의 세트에 모든 라인

### 캐시 교체 정책 ◑

| 정책 | 설명 |
|------|------|
| LRU (Least Recently Used) | 가장 오래 사용 안 된 라인 교체 |
| FIFO | 가장 먼저 들어온 라인 교체 |
| Random | 무작위 선택 |

### ⭕ Write-through와 Write-back의 차이는?

| 정책 | 동작 | 장점 | 단점 |
|------|------|------|------|
| **Write-through** | 캐시와 메모리 동시 쓰기 | 일관성 유지 쉬움 | 쓰기 느림 |
| **Write-back** | 캐시만 쓰고 나중에 메모리 갱신 | 쓰기 빠름 | Dirty bit 필요, 일관성 복잡 |

### 캐시 미스 유형 (3C) ◑

| 유형 | 설명 |
|------|------|
| **Compulsory (Cold)** | 최초 접근 시 발생 |
| **Capacity** | 캐시 용량 부족 |
| **Conflict** | 같은 세트에 매핑되어 충돌 |

### ⭕ 캐시 일관성 (Cache Coherence)이란?

멀티코어 시스템에서 여러 캐시가 동일 메모리 위치를 캐싱할 때 일관성을 유지하는 것이다.

**MESI 프로토콜:**

| 상태 | 의미 |
|------|------|
| **M**odified | 수정됨, 이 캐시에만 존재 |
| **E**xclusive | 수정 안 됨, 이 캐시에만 존재 |
| **S**hared | 수정 안 됨, 여러 캐시에 존재 |
| **I**nvalid | 무효 상태 |

```
예시: 변수 x = 10이 메모리에 있음

1. Core1이 x 읽음 → Core1 캐시: E (Exclusive)
2. Core2도 x 읽음 → 둘 다: S (Shared)
3. Core1이 x = 20으로 수정 → Core1: M (Modified), Core2: I (Invalid)
4. Core2가 x 읽으려 함 → Core1이 메모리에 쓰고, 둘 다: S (Shared)
```

---

## 3. 파이프라이닝

### 파이프라이닝이란?

최소의 하드웨어를 가지고 최고의 성능을 낼 수 있도록 instruction의 실행을 overlap하는 기법

### 파이프라인 5단계 (MIPS 기준)

1. **IF** (Instruction Fetch): 명령어 인출
2. **ID** (Instruction Decode): 명령어 해독 + 레지스터 읽기
3. **EX** (Execute): 연산 수행
4. **MEM** (Memory Access): 메모리 접근
5. **WB** (Write Back): 결과 저장

### ⭕ 파이프라인 해저드란 무엇이고, 어떤 종류가 있는가?

파이프라인 실행을 방해하는 세 가지 유형의 문제:

| 해저드 유형 | 설명 | 해결 방법 |
|------------|------|----------|
| 자원 해저드 (Structural) | 하드웨어 자원 충돌 | 자원 추가, 파이프라인 스톨 |
| 데이터 해저드 (Data) | 명령어 간 데이터 의존성 | 포워딩, 스톨, 레지스터 리네이밍 |
| 제어 해저드 (Control) | 분기 명령어로 인한 PC 변경 | 분기 예측, 지연 분기 |

### ⭕ 분기 예측 (Branch Prediction) ◑

분기 명령어의 결과를 미리 예측하여 파이프라인 스톨을 줄이는 기법이다.

| 구분 | 정적 예측 | 동적 예측 |
|------|-----------|-----------|
| 방식 | 컴파일 타임 결정 | 실행 히스토리 기반 |
| 정확도 | ~60-70% | ~90% 이상 |
| 예시 | Always Taken, BTFNT | 2-bit Predictor, 상관 예측기 |

- **BTFNT**: Backward Taken, Forward Not Taken (뒤로 분기는 루프로 간주하여 Taken 예측)

**2-bit Saturating Counter:**
- 4개 상태: Strongly Taken → Weakly Taken → Weakly Not Taken → Strongly Not Taken
- 예측 실패 2번 연속 시에만 예측 방향 변경
- 루프 마지막 반복에서만 오예측 발생

**BTB (Branch Target Buffer):**
- 분기 목적지 주소를 캐싱하는 테이블
- 분기 명령어 fetch 시 함께 조회하여 지연 최소화

### 데이터 해저드의 세부 유형

- **RAW (Read After Write)**: 참 의존성 - 이전 명령어의 결과가 필요
- **WAR (Write After Read)**: 역의존성 - 레지스터 리네이밍으로 해결
- **WAW (Write After Write)**: 출력 의존성 - 레지스터 리네이밍으로 해결

---

## 4. CPU 발전 과정

### ⭕ CISC와 RISC의 차이는?

| 구분 | CISC | RISC |
|------|------|------|
| 명령어 | 복잡하고 다양함 | 단순하고 적음 |
| 명령어 길이 | 가변 길이 | 고정 길이 |
| 실행 | 명령어당 여러 사이클 | 파이프라이닝 최적화 (1 IPC 목표) |
| 메모리 접근 | 다양한 주소 지정 모드 | LOAD-STORE 아키텍처 |
| 예시 | x86, x86-64 | ARM, MIPS, RISC-V |

### RISC의 특징

- **LOAD-STORE 아키텍처**: 메모리 접근은 오직 LOAD/STORE 명령어만
- **고정 길이 명령어**: 디코딩 단순화, 파이프라이닝에 유리
- **많은 범용 레지스터**: 메모리 접근 최소화

### ⭕ 슈퍼스칼라와 비순차 실행 ◑

**슈퍼스칼라 (Superscalar):**
- 한 사이클에 여러 명령어를 동시에 발행/실행
- 여러 실행 유닛 (ALU, FPU, Load/Store 등) 보유
- 예: Intel Core (4-wide), AMD Zen (6-wide)

**비순차 실행 (Out-of-Order Execution):**
- 데이터 의존성이 없는 명령어를 먼저 실행
- 프로그램 순서와 다르게 실행하되, 결과는 순서대로 커밋

| 구성 요소 | 역할 |
|-----------|------|
| Reservation Station | 피연산자 대기, 준비되면 실행 |
| Register Renaming | WAR, WAW 해저드 제거 |
| Reorder Buffer (ROB) | 순서대로 커밋, 정확한 예외 처리 |

---

## 5. 컴파일 과정

### 프로그래밍 역사

천공 카드 → 어셈블리어 → 고급 언어

### ⭕ 컴파일 과정을 설명하라

| 단계 | 설명 | 산출물 |
|------|------|--------|
| 1. 어휘 분석 (Lexical) | 소스 코드를 토큰으로 분리 | 토큰 스트림 |
| 2. 구문 분석 (Syntax) | 문법 검사, 파싱 | 파싱 트리 (AST) |
| 3. 의미 분석 (Semantic) | 타입 검사, 의미 검증 | 심볼 테이블 |
| 4. 중간 코드 생성 | 플랫폼 독립적 중간 표현 | IR (Intermediate Representation) |
| 5. 최적화 | 코드 효율성 개선 | 최적화된 IR |
| 6. 코드 생성 | 타겟 기계어 생성 | 목적 파일 (.o, .obj) |

---

## 6. 링커와 로더

### 링커 (Linker)

여러 목적 파일을 하나의 실행 파일로 연결

**링커의 역할:**
1. **심볼 해석 (Symbol Resolution)**: 외부 참조를 정의와 연결
2. **주소 할당**: 각 섹션의 메모리 주소 결정
3. **재배치 (Relocation)**: 상대 주소를 절대 주소로 변환

### 로더 (Loader)

실행 파일을 메모리에 적재하고 실행 준비

**로더의 역할:**
1. 메모리 할당
2. 프로그램 적재
3. 동적 링킹 (필요시)
4. 제어권 전달

---

## 7. 가상 주소와 메모리 구조

### 프로세스 메모리 구조

```
높은 주소
┌─────────────────┐
│     Stack       │  ← 지역 변수, 함수 호출 정보
│       ↓         │
├─────────────────┤
│                 │
│    (빈 공간)     │
│                 │
├─────────────────┤
│       ↑         │
│     Heap        │  ← 동적 할당 메모리
├─────────────────┤
│     BSS         │  ← 초기화되지 않은 전역/정적 변수
├─────────────────┤
│     Data        │  ← 초기화된 전역/정적 변수
├─────────────────┤
│     Text        │  ← 실행 코드
└─────────────────┘
낮은 주소
```

### 가상 메모리

- 물리 메모리보다 큰 주소 공간 제공
- 프로세스 간 메모리 격리
- 페이지 단위로 관리

---

## 8. GPU와 병렬 처리 ◑

### ⭕ CPU와 GPU의 차이는?

| 구분 | CPU | GPU |
|------|-----|-----|
| 코어 수 | 소수 (4~64) | 수천 개 (1000~10000+) |
| 코어 특성 | 복잡, 고성능 | 단순, 저성능 |
| 적합 작업 | 순차 처리, 복잡한 로직 | 병렬 처리, 동일 연산 대량 수행 |
| 캐시 | 코어당 큰 캐시 | 작은 공유 캐시 |
| 메모리 | 시스템 메모리 (DDR) | 전용 메모리 (GDDR, HBM) |

### GPU 아키텍처 기본 ◑

```
GPU
├── SM (Streaming Multiprocessor) × N
│   ├── CUDA Core / Shader Unit × M
│   ├── Warp Scheduler
│   ├── Shared Memory
│   └── L1 Cache
├── L2 Cache (공유)
└── VRAM (Global Memory)
```

- **Warp/Wavefront**: 32개(NVIDIA) 또는 64개(AMD) 스레드가 동시에 같은 명령 실행 (SIMT)
- **SIMT (Single Instruction, Multiple Threads)**: SIMD의 GPU 확장

### GPU 활용 분야 ◑

| 분야 | 설명 |
|------|------|
| 그래픽스 | 렌더링, 셰이딩 |
| GPGPU | 범용 연산 (CUDA, OpenCL) |
| AI/ML | 딥러닝 학습 및 추론 |
| 암호화폐 | 채굴 연산 |

---

## 9. 메모리 하드웨어 ◑

### 메모리 종류 ◑

| 종류 | 특징 | 용도 |
|------|------|------|
| **SRAM** | 플립플롭 기반, 빠름, 비쌈 | 캐시, 레지스터 |
| **DRAM** | 커패시터 기반, 리프레시 필요 | 메인 메모리 |
| **SDRAM** | 클럭 동기화 DRAM | - |
| **DDR SDRAM** | Double Data Rate (클럭 상승/하강 모두 전송) | DDR4, DDR5 |
| **GDDR** | 그래픽용 DDR, 높은 대역폭 | GPU 메모리 |
| **HBM** | 3D 적층, 초고대역폭 | 고성능 GPU, AI 가속기 |

### ⭕ SRAM과 DRAM의 차이는?

| 구분 | SRAM | DRAM |
|------|------|------|
| 구조 | 6개 트랜지스터 (플립플롭) | 1 트랜지스터 + 1 커패시터 |
| 속도 | 빠름 | 느림 |
| 밀도 | 낮음 | 높음 |
| 비용 | 비쌈 | 저렴 |
| 리프레시 | 불필요 | 필요 (주기적) |
| 용도 | 캐시 메모리 | 메인 메모리 |

### 메모리 대역폭과 레이턴시 ◑

- **대역폭 (Bandwidth)**: 단위 시간당 전송 가능한 데이터량 (GB/s)
- **레이턴시 (Latency)**: 요청부터 응답까지 지연 시간 (ns)

```
DDR5-6400: 대역폭 ~51.2 GB/s, 레이턴시 ~14ns
HBM3:      대역폭 ~800 GB/s 이상, 레이턴시 비슷
```

---

## 10. 버스와 I/O ◑

### 버스 (Bus) ◑

컴퓨터 내부에서 데이터를 전송하는 통로이다.

| 버스 종류 | 연결 대상 |
|-----------|----------|
| 시스템 버스 | CPU - 메모리 |
| I/O 버스 | CPU/메모리 - 주변장치 |
| 확장 버스 | 확장 카드 (PCIe 등) |

### 주요 인터페이스 ◑

| 인터페이스 | 용도 | 대역폭 |
|------------|------|--------|
| **PCIe 4.0 x16** | GPU, NVMe | ~32 GB/s |
| **PCIe 5.0 x16** | 차세대 GPU | ~64 GB/s |
| **NVMe** | SSD | PCIe 기반 |
| **SATA** | HDD/SSD (레거시) | ~600 MB/s |
| **USB 3.2** | 주변기기 | ~20 Gbps |
| **Thunderbolt 4** | 고속 주변기기 | ~40 Gbps |

### ⭕ 인터럽트 (Interrupt)란?

CPU가 현재 작업을 중단하고 우선 처리해야 할 이벤트를 알리는 신호이다.

| 종류 | 설명 | 예시 |
|------|------|------|
| **하드웨어 인터럽트** | 외부 장치에서 발생 | 키보드 입력, 타이머 |
| **소프트웨어 인터럽트** | 명령어로 발생 | 시스템 콜 (INT 0x80) |
| **예외 (Exception)** | 오류나 특수 상황 | 0으로 나누기, 페이지 폴트 |

**인터럽트 처리 과정:**
1. 인터럽트 발생
2. 현재 상태 저장 (레지스터, PC)
3. 인터럽트 벡터 테이블에서 핸들러 주소 조회
4. ISR (Interrupt Service Routine) 실행
5. 상태 복원 후 원래 작업 재개

### ⭕ DMA (Direct Memory Access)란? ◑

CPU 개입 없이 주변장치와 메모리 간 직접 데이터 전송하는 방식이다.

| 방식 | 동작 | CPU 부담 |
|------|------|----------|
| Programmed I/O | CPU가 직접 전송 | 높음 |
| Interrupt-driven I/O | 인터럽트 기반 | 중간 |
| **DMA** | DMA 컨트롤러가 전송 | 낮음 |

**DMA 장점:**
- CPU가 다른 작업 수행 가능
- 대용량 데이터 전송에 효율적 (디스크 I/O, 네트워크)

---

## 11. 명령어 집합 구조 (ISA) ◑

### ⭕ ISA란?

Instruction Set Architecture의 약자로, 하드웨어와 소프트웨어 간의 인터페이스를 정의한다.

| 구성 요소 | 설명 |
|-----------|------|
| 명령어 종류 | 산술, 논리, 분기, 메모리 접근 등 |
| 레지스터 | 개수, 크기, 용도 |
| 주소 지정 모드 | 피연산자 위치 지정 방식 |
| 데이터 타입 | 정수, 부동소수점 등 |

### 주요 ISA ◑

| ISA | 특징 | 사용처 |
|-----|------|--------|
| **x86-64** | CISC, 호환성 | PC, 서버 |
| **ARM** | RISC, 저전력 | 모바일, 임베디드, Apple Silicon |
| **RISC-V** | 오픈소스 RISC | 임베디드, 연구, 확대 중 |
| **MIPS** | 교육용 RISC | 학습, 일부 임베디드 |

### 주소 지정 모드 ◑

| 모드 | 설명 | 예시 |
|------|------|------|
| 즉시 (Immediate) | 피연산자가 명령어에 포함 | `MOV R1, #5` |
| 레지스터 (Register) | 레지스터에 저장된 값 | `MOV R1, R2` |
| 직접 (Direct) | 메모리 주소 직접 지정 | `MOV R1, [0x1000]` |
| 간접 (Indirect) | 레지스터에 저장된 주소 | `MOV R1, [R2]` |
| 인덱스 (Indexed) | 베이스 + 오프셋 | `MOV R1, [R2+4]` |

---

## 면접 대비 체크리스트 ◑

- [ ] 폰 노이만 구조와 메모리 계층 구조
- [ ] 캐시 매핑 방식 (Direct, Set-Associative, Fully-Associative)
- [ ] Write-through vs Write-back
- [ ] 캐시 일관성 (MESI 프로토콜)
- [ ] 파이프라이닝 5단계와 해저드 종류
- [ ] 분기 예측 (정적/동적, 2-bit predictor, BTB)
- [ ] 데이터 해저드 (RAW, WAR, WAW)
- [ ] CISC vs RISC
- [ ] 슈퍼스칼라와 비순차 실행
- [ ] 컴파일 과정 6단계
- [ ] 프로세스 메모리 구조 (Text, Data, BSS, Heap, Stack)
- [ ] CPU vs GPU 아키텍처 차이
- [ ] SRAM vs DRAM
- [ ] 인터럽트 종류와 처리 과정
- [ ] DMA 동작 원리
- [ ] ISA와 주소 지정 모드
- [ ] PCIe, NVMe 등 주요 인터페이스
