# 07. 소프트웨어 공학과 아키텍처 (Software Engineering & Architecture)

---

# Part A. 소프트웨어 공학

## 1. 소프트웨어 개발 생명주기

### SDLC (Software Development Life Cycle)

**주요 단계:**
1. 요구사항 분석
2. 설계
3. 구현
4. 테스트
5. 배포
6. 유지보수

---

## 2. 개발 방법론

### Waterfall Model

순차적 단계 진행 방식

| 장점 | 단점 |
|------|------|
| 단순하고 이해하기 쉬움 | 변경에 유연하지 않음 |
| 문서화가 잘 됨 | 후반부에 문제 발견 시 비용 큼 |

### ⭕ 애자일과 워터폴의 차이는?

| 구분 | Waterfall | Agile |
|------|-----------|-------|
| 진행 방식 | 순차적 | 반복적 |
| 요구사항 | 초기에 확정 | 변경 수용 |
| 문서화 | 상세한 문서 | 동작하는 소프트웨어 우선 |
| 고객 참여 | 초기/후기 | 지속적 |
| 적합한 경우 | 요구사항 명확 | 요구사항 불확실 |

### Agile Model

**핵심 가치 (Agile Manifesto):**
- 프로세스/도구보다 **개인과 상호작용**
- 문서보다 **동작하는 소프트웨어**
- 계약 협상보다 **고객 협력**
- 계획 따르기보다 **변화에 대응**

### 애자일 프레임워크

| 프레임워크 | 특징 |
|------------|------|
| **Scrum** | 스프린트(2-4주), 데일리 스탠드업, 스프린트 리뷰 |
| **Kanban** | 시각적 보드, WIP 제한, 지속적 흐름 |
| **XP** | 페어 프로그래밍, TDD, 지속적 통합 |

---

## 3. 소프트웨어 테스팅

### ISTQB 테스팅 7원칙

| 원칙 | 설명 |
|------|------|
| 1. 결함 발견 | 테스팅은 결함 존재를 발견하기 위한 활동 |
| 2. 완벽한 테스팅 불가능 | 모든 조합 테스트 불가 → 위험 분석으로 집중 |
| 3. 초기 테스팅 | 개발 초기부터 시작하면 비용 효율적 |
| 4. 결함 집중 | 특정 모듈에 결함이 집중 (파레토 법칙) |
| 5. 살충제 패러독스 | 반복된 동일 테스트는 효율 저하 |
| 6. 문맥 의존성 | 상황에 맞는 테스팅 방법 필요 |
| 7. 오류 부재의 오류 | 결함 미발견이 완벽성을 의미하지 않음 |

### ⭕ Verification과 Validation의 차이는?

| 구분 | Verification (검증) | Validation (확인) |
|------|---------------------|-------------------|
| 질문 | "제품을 올바르게 만들고 있는가?" | "올바른 제품을 만들고 있는가?" |
| 초점 | 명세 준수 확인 | 사용자 요구 충족 확인 |
| 방법 | 리뷰, 인스펙션 | 테스팅, 사용자 검증 |

### 테스팅 레벨

| 레벨 | 설명 |
|------|------|
| 단위 테스트 | 개별 모듈/함수 테스트 |
| 통합 테스트 | 모듈 간 인터페이스 테스트 |
| 시스템 테스트 | 전체 시스템 테스트 |
| 인수 테스트 | 고객 관점 테스트 |

### 테스팅 기법

| 기법 | 설명 |
|------|------|
| **블랙박스** | 내부 구조 모르고 입출력만 테스트 |
| **화이트박스** | 내부 구조 알고 코드 기반 테스트 |

---

## 4. CI/CD

### CI (Continuous Integration)

코드 변경 시 자동으로 빌드/테스트 수행

### CD (Continuous Delivery/Deployment)

| 구분 | Continuous Delivery | Continuous Deployment |
|------|--------------------|-----------------------|
| 배포 | 수동 승인 후 배포 | 자동 배포 |

### CI/CD 파이프라인

```
코드 커밋 → 빌드 → 테스트 → 스테이징 → (승인) → 프로덕션
```

---

# Part B. 소프트웨어 아키텍처

## 5. 객체지향 프로그래밍

### ⭕ OOP의 4대 특성을 설명하라

| 특성 | 설명 |
|------|------|
| **추상화** | 복잡한 세부사항을 숨기고 중요한 측면 강조 |
| **캡슐화** | 정보 은닉을 통한 데이터 보호 |
| **상속** | 기반 클래스의 속성과 메서드를 물려받음 |
| **다형성** | 하나의 인터페이스로 다양한 구현 동작 |

### ⭕ 상속보다 합성을 선호하는 이유는?

| 방식 | 장점 | 단점 |
|------|------|------|
| **상속** | 코드 간결 | 결합도 높음 |
| **합성** | 런타임에 동적 결정 | wrapping 코드 증가 |

상속은 결합도가 높아 부모 변경 시 자식에게 영향. 합성은 유연하고 결합도가 낮다.

---

## 6. SOLID 원칙

### ⭕ SOLID 원칙을 설명하라

| 원칙 | 이름 | 의미 |
|------|------|------|
| **S**RP | Single Responsibility | 클래스는 하나의 책임만 가져야 함 |
| **O**CP | Open-Closed | 확장에는 열려있고, 변경에는 닫혀있어야 함 |
| **L**SP | Liskov Substitution | 하위 타입은 상위 타입을 대체할 수 있어야 함 |
| **I**SP | Interface Segregation | 범용 인터페이스보다 특정 인터페이스가 나음 |
| **D**IP | Dependency Inversion | 구체화가 아닌 추상화에 의존해야 함 |

---

## 7. 클래스 간 관계

### 관계의 결합도 순서

```
Dependency < Association < Aggregation < Composition < Inheritance
 (의존)       (연관)        (집합)        (합성)        (상속)
```

| 관계 | 설명 | UML 표기 |
|------|------|----------|
| **Dependency** | 일시적 사용 관계 | 점선 화살표 |
| **Association** | 지속적 참조 관계 | 실선 화살표 |
| **Aggregation** | 부분-전체, 생명주기 독립 | 빈 다이아몬드 |
| **Composition** | 부분-전체, 생명주기 종속 | 채운 다이아몬드 |
| **Inheritance** | is-a 관계 | 빈 삼각형 화살표 |

---

## 8. 디자인 패턴

자주 반복되는 설계 문제에 대한 널리 알려진 해결책 (GoF 23가지 패턴)

### 패턴 분류

| 분류 | 목적 | 예시 |
|------|------|------|
| **생성 패턴** | 객체 생성 책임 분리 | Singleton, Factory, Builder, Prototype, Abstract Factory |
| **구조 패턴** | 클래스/객체 조합 | Adapter, Decorator, Proxy, Facade, Composite, Bridge, Flyweight |
| **행위 패턴** | 객체 행동과 책임 분배 | Observer, Strategy, Template Method, Command, State, Iterator, Chain of Responsibility |

### 생성 패턴 (Creational) ◑

#### ⭕ Singleton 패턴의 장단점은?

**장점:** 인스턴스 하나, 메모리 절약, 전역 접근

**단점:** 테스트 어려움, 전역 상태 부작용, 멀티스레드 주의

| 패턴 | 설명 | 사용 시점 |
|------|------|----------|
| **Singleton** | 인스턴스가 하나만 존재 | 설정, 로거, DB 커넥션 풀 |
| **Factory Method** | 객체 생성을 서브클래스에 위임 | 생성 로직 캡슐화 |
| **Abstract Factory** | 관련 객체군을 생성하는 인터페이스 | UI 테마, 플랫폼별 객체 |
| **Builder** | 복잡한 객체를 단계별로 생성 | 많은 매개변수, 불변 객체 |
| **Prototype** | 기존 객체를 복제하여 생성 | 생성 비용이 큰 객체 |

#### ⭕ Factory Method vs Abstract Factory ◑

| 구분 | Factory Method | Abstract Factory |
|------|----------------|------------------|
| 생성 대상 | 단일 객체 | 객체 군(family) |
| 구현 | 상속 기반 | 구성(composition) 기반 |
| 확장 | 새 Product 추가 용이 | 새 Factory 추가 용이 |

### 구조 패턴 (Structural) ◑

| 패턴 | 설명 | 사용 시점 |
|------|------|----------|
| **Adapter** | 호환되지 않는 인터페이스 연결 | 레거시 코드 통합, 외부 라이브러리 |
| **Decorator** | 객체에 동적으로 책임 추가 | 기능 조합이 다양할 때 |
| **Proxy** | 대리 객체로 접근 제어 | 지연 로딩, 캐싱, 접근 제어 |
| **Facade** | 복잡한 서브시스템에 단순한 인터페이스 | API 간소화, 라이브러리 래핑 |
| **Composite** | 트리 구조로 부분-전체 계층 표현 | 파일 시스템, UI 컴포넌트 |
| **Bridge** | 추상화와 구현을 분리 | 다차원 확장 시 |
| **Flyweight** | 공유로 메모리 절약 | 대량의 유사 객체 |

#### ⭕ Adapter vs Facade vs Proxy ◑

| 패턴 | 목적 |
|------|------|
| **Adapter** | 인터페이스 **변환** |
| **Facade** | 인터페이스 **단순화** |
| **Proxy** | 인터페이스 **유지** + 기능 추가 (접근 제어, 캐싱) |

### 행위 패턴 (Behavioral) ◑

| 패턴 | 설명 | 사용 시점 |
|------|------|----------|
| **Strategy** | 알고리즘 군을 정의하고 런타임에 교환 | 정렬 방식, 결제 방식 |
| **Observer** | 상태 변화 시 의존 객체들에게 통지 | 이벤트 시스템, MVC |
| **Template Method** | 알고리즘 골격 정의, 세부 단계는 서브클래스 | 프레임워크 훅 |
| **Command** | 요청을 객체로 캡슐화 | Undo/Redo, 작업 큐 |
| **State** | 상태에 따라 행동 변경 | 상태 기계 |
| **Iterator** | 컬렉션 순회 방법 통일 | 컬렉션 순회 |
| **Chain of Responsibility** | 요청을 핸들러 체인으로 전달 | 미들웨어, 이벤트 버블링 |

#### ⭕ Strategy vs State ◑

| 구분 | Strategy | State |
|------|----------|-------|
| 목적 | 알고리즘 교체 | 상태에 따른 행동 변경 |
| 전환 주체 | 클라이언트 | 객체 스스로 또는 컨텍스트 |
| 인식 | 전략 간 서로 모름 | 상태 간 전환 알 수 있음 |

#### ⭕ Observer 패턴 (Pub/Sub) ◑

```
Subject (Publisher)
    ├── attach(observer)
    ├── detach(observer)
    └── notify()  →  Observer1.update()
                  →  Observer2.update()
                  →  Observer3.update()
```

**장점:** 느슨한 결합, 동적 구독

**단점:** 순서 보장 어려움, 메모리 누수 주의 (구독 해제)

---

## 9. UML 다이어그램

| 다이어그램 | 용도 |
|------------|------|
| **Use Case** | 시스템과 Actor의 상호작용 시각화 |
| **Class** | 객체의 속성, 동작, 관계 정의 |
| **Sequence** | 객체 간 상호작용을 시간 순서로 표현 |
| **State Machine** | 객체의 상태 전이 표현 |
| **Activity** | 업무 흐름, 프로세스 표현 |

---

## 10. 아키텍처 뷰

### SW Architecture View

| 뷰 | 관점 | 설명 |
|----|------|------|
| **Module View** | 개발자 | 정적 설계, 코드 구조 |
| **Runtime View (C&C)** | 사용자 | 실행 시 존재하는 요소들 |
| **Allocation View** | 운영 | 배치 및 배포 관계 |

---

## 11. 소프트웨어 아키텍처 스타일 ◑

### ⭕ 모놀리식과 마이크로서비스의 차이는?

| 구분 | 모놀리식 (Monolithic) | 마이크로서비스 (MSA) |
|------|----------------------|---------------------|
| 구조 | 단일 코드베이스, 통합 배포 | 독립적인 서비스들로 구성 |
| 배포 | 전체 배포 | 서비스별 독립 배포 |
| 확장 | 전체 확장 | 서비스별 개별 확장 |
| 기술 스택 | 단일 | 서비스별 다양 |
| 통신 | 함수 호출 | API (HTTP, gRPC, 메시지 큐) |
| 장애 영향 | 전체 시스템 | 해당 서비스만 (격리) |
| 복잡도 | 단순 | 운영/배포 복잡 |

### MSA 적합한 경우 ◑

| 적합 | 부적합 |
|------|--------|
| 대규모 팀, 독립적 개발 필요 | 소규모 팀, 간단한 서비스 |
| 서비스별 확장 요구 다름 | 빠른 MVP 개발 |
| 장기적 유지보수 예상 | 도메인 경계가 불명확 |

### 주요 아키텍처 스타일 ◑

#### Layered Architecture (계층형) ◑

```
┌──────────────────────────┐
│   Presentation Layer     │  ← UI, Controller
├──────────────────────────┤
│   Business Logic Layer   │  ← Service, Domain
├──────────────────────────┤
│   Data Access Layer      │  ← Repository, DAO
├──────────────────────────┤
│   Database               │
└──────────────────────────┘
```

**장점:** 관심사 분리, 이해하기 쉬움
**단점:** 수직적 의존성, 계층 우회 유혹

#### ⭕ Hexagonal Architecture (육각형 / 포트와 어댑터) ◑

핵심 비즈니스 로직을 외부 의존성으로부터 격리한다.

```
        ┌─────────────────────────────────┐
        │           Adapters              │
        │  ┌───────────────────────────┐  │
        │  │         Ports             │  │
        │  │  ┌───────────────────┐   │  │
        │  │  │   Domain Core     │   │  │
        │  │  │  (Business Logic) │   │  │
        │  │  └───────────────────┘   │  │
        │  └───────────────────────────┘  │
        └─────────────────────────────────┘
```

| 구성 요소 | 설명 |
|-----------|------|
| **Domain Core** | 순수 비즈니스 로직, 외부 의존성 없음 |
| **Port** | 인터페이스 (입력/출력 정의) |
| **Adapter** | Port 구현체 (DB, API, UI 연결) |

**장점:** 테스트 용이, 기술 독립적
**사용:** DDD, Clean Architecture

#### Event-Driven Architecture ◑

이벤트를 통해 느슨하게 결합된 서비스 간 통신한다.

| 패턴 | 설명 |
|------|------|
| **Event Notification** | 이벤트 발생만 알림 |
| **Event-Carried State Transfer** | 이벤트에 상태 데이터 포함 |
| **Event Sourcing** | 모든 상태 변경을 이벤트로 저장 |

**장점:** 느슨한 결합, 확장성, 비동기 처리
**단점:** 디버깅 어려움, 최종 일관성

#### ⭕ CQRS (Command Query Responsibility Segregation) ◑

명령(쓰기)과 조회(읽기) 모델을 분리한다.

```
┌─────────────┐     ┌─────────────┐
│   Command   │     │    Query    │
│   (Write)   │     │   (Read)    │
└──────┬──────┘     └──────┬──────┘
       │                   │
       ▼                   ▼
┌─────────────┐     ┌─────────────┐
│ Write Model │     │ Read Model  │
│  (Normalize)│     │ (Denormalize)│
└─────────────┘     └─────────────┘
```

**적합한 경우:** 읽기/쓰기 비율 차이 큼, 복잡한 도메인
**주의:** 복잡도 증가, 최종 일관성

#### Event Sourcing ◑

현재 상태 대신 이벤트 시퀀스를 저장한다.

```
Event Store:
[OrderCreated] → [ItemAdded] → [ItemAdded] → [OrderPaid] → [OrderShipped]
                                                ↓
                                         현재 상태 재구성
```

**장점:** 완전한 감사 로그, 시간 여행 가능
**단점:** 복잡한 구현, 이벤트 스키마 진화

#### Clean Architecture ◑

| 계층 | 설명 |
|------|------|
| **Entities** | 핵심 비즈니스 규칙 |
| **Use Cases** | 애플리케이션 비즈니스 규칙 |
| **Interface Adapters** | Controller, Presenter, Gateway |
| **Frameworks & Drivers** | DB, Web, UI |

**의존성 규칙:** 바깥 계층 → 안쪽 계층 (안쪽은 바깥을 모름)

#### 서버리스 아키텍처 ◑

| 특징 | 설명 |
|------|------|
| **FaaS** | 함수 단위 실행, 요청 시 시작 |
| **Cold Start** | 첫 호출 시 지연 발생 |
| **Stateless** | 상태를 외부 저장소에 보관 |

**장점:** 비용 효율, 자동 확장
**단점:** Cold Start, 벤더 종속

---

## 12. 품질 속성 (NFR)

| 속성 | 설명 |
|------|------|
| **Modifiability** | 변경 비용 최소화 |
| **Availability** | 시스템 신뢰성과 회복 |
| **Security** | 승인받지 않은 접근 방지 |
| **Usability** | 사용 용이성 |
| **Performance** | 제약 시간 내 처리 |
| **Scalability** | 부하 증가에 대한 확장성 |

---

## 면접 대비 체크리스트 ◑

**개발 방법론**
- [ ] 애자일 vs 워터폴 차이
- [ ] Verification vs Validation
- [ ] CI/CD 파이프라인

**OOP와 설계 원칙**
- [ ] OOP 4대 특성
- [ ] SOLID 원칙
- [ ] 상속 vs 합성
- [ ] 클래스 관계 결합도 순서

**디자인 패턴**
- [ ] 생성 패턴: Singleton, Factory Method, Abstract Factory, Builder
- [ ] 구조 패턴: Adapter, Decorator, Proxy, Facade
- [ ] 행위 패턴: Strategy, Observer, Command, State
- [ ] Factory Method vs Abstract Factory 차이
- [ ] Adapter vs Facade vs Proxy 차이
- [ ] Strategy vs State 차이

**아키텍처**
- [ ] 모놀리식 vs 마이크로서비스
- [ ] Layered Architecture
- [ ] Hexagonal Architecture (포트와 어댑터)
- [ ] Event-Driven Architecture
- [ ] CQRS와 Event Sourcing
- [ ] Clean Architecture

